#include <stdderiv.h>

#define LDENSITY (1)
#define LHYDRO (1)
#define LMAGNETIC (0)
#define LENTROPY (1)
#define LTEMPERATURE (0)
#define LFORCING (0)
#define LUPWD (0)
#define LSINK (0)
#define LBFIELD (0)

#define AC_THERMAL_CONDUCTIVITY (0.001) // TODO: make an actual config parameter
#define H_CONST (0)                     // TODO: make an actual config parameter
#define C_CONST (0)                     // TODO: make an actual config parameter

// Int params
uniform int AC_max_steps;
uniform int AC_save_steps;
uniform int AC_bin_steps;
uniform int AC_start_step;

uniform int AC_bc_type_top_x;
uniform int AC_bc_type_bot_x;
uniform int AC_bc_type_top_y;
uniform int AC_bc_type_bot_y;
uniform int AC_bc_type_top_z;
uniform int AC_bc_type_bot_z;

// Real params
uniform Scalar AC_dt;
uniform Scalar AC_max_time;
// Spacing
uniform Scalar AC_dsmin;
// physical grid
uniform Scalar AC_xlen;
uniform Scalar AC_ylen;
uniform Scalar AC_zlen;
uniform Scalar AC_xorig;
uniform Scalar AC_yorig;
uniform Scalar AC_zorig;
// Physical units
uniform Scalar AC_unit_density;
uniform Scalar AC_unit_velocity;
uniform Scalar AC_unit_length;
uniform Scalar AC_unit_magnetic;
// properties of gravitating star
uniform Scalar AC_star_pos_x;
uniform Scalar AC_star_pos_y;
uniform Scalar AC_star_pos_z;
uniform Scalar AC_M_star;
// properties of sink particle
uniform Scalar AC_sink_pos_x;
uniform Scalar AC_sink_pos_y;
uniform Scalar AC_sink_pos_z;
uniform Scalar AC_M_sink;
uniform Scalar AC_M_sink_init;
uniform Scalar AC_M_sink_Msun;
uniform Scalar AC_soft;
uniform Scalar AC_accretion_range;
uniform Scalar AC_switch_accretion;
//  Run params
uniform Scalar AC_cdt;
uniform Scalar AC_cdtv;
uniform Scalar AC_cdts;
uniform Scalar AC_nu_visc;
uniform Scalar AC_cs_sound = 1.0;
uniform Scalar AC_eta;
uniform Scalar AC_mu0;
uniform Scalar AC_cp_sound;
uniform Scalar AC_gamma;
uniform Scalar AC_cv_sound;
uniform Scalar AC_lnT0;
uniform Scalar AC_lnrho0;
uniform Scalar AC_zeta;
uniform Scalar AC_trans;
//  Other
uniform Scalar AC_bin_save_t;
//  Initial condition params
uniform Scalar AC_ampl_lnrho;
uniform Scalar AC_ampl_uu;
uniform Scalar AC_angl_uu;
uniform Scalar AC_lnrho_edge;
uniform Scalar AC_lnrho_out;
uniform Scalar AC_ampl_aa;
uniform Scalar AC_init_k_wave;
uniform Scalar AC_init_sigma_hel;
//  Forcing parameters. User configured.
uniform Scalar AC_forcing_magnitude;
uniform Scalar AC_relhel;
uniform Scalar AC_kmin;
uniform Scalar AC_kmax;
//  Forcing parameters. Set by the generator.
uniform Scalar AC_forcing_phase;
uniform Scalar AC_k_forcex;
uniform Scalar AC_k_forcey;
uniform Scalar AC_k_forcez;
uniform Scalar AC_kaver;
uniform Scalar AC_ff_hel_rex;
uniform Scalar AC_ff_hel_rey;
uniform Scalar AC_ff_hel_rez;
uniform Scalar AC_ff_hel_imx;
uniform Scalar AC_ff_hel_imy;
uniform Scalar AC_ff_hel_imz;
//  Additional helper params  //  (deduced from other params do not set these directly!)
uniform Scalar AC_G_const;
uniform Scalar AC_GM_star;
uniform Scalar AC_unit_mass;
uniform Scalar AC_sq2GM_star;
uniform Scalar AC_cs2_sound = AC_cs_sound * AC_cs_sound;

/*
 * =============================================================================
 * User-defined vertex buffers
 * =============================================================================
 */
#if LENTROPY
uniform ScalarField VTXBUF_LNRHO;
uniform ScalarField VTXBUF_UUX;
uniform ScalarField VTXBUF_UUY;
uniform ScalarField VTXBUF_UUZ;
uniform ScalarField VTXBUF_ENTROPY;
#else
uniform ScalarField VTXBUF_LNRHO;
#endif

#if LUPWD

Preprocessed Scalar
der6x_upwd(in ScalarField vertex)
{
    Scalar inv_ds = AC_inv_dsx;

    return (Scalar){(1.0 / 60.0) * inv_ds *
                    (-20.0 * vertex[vertexIdx.x, vertexIdx.y, vertexIdx.z] +
                     15.0 * (vertex[vertexIdx.x + 1, vertexIdx.y, vertexIdx.z] +
                             vertex[vertexIdx.x - 1, vertexIdx.y, vertexIdx.z]) -
                     6.0 * (vertex[vertexIdx.x + 2, vertexIdx.y, vertexIdx.z] +
                            vertex[vertexIdx.x - 2, vertexIdx.y, vertexIdx.z]) +
                     vertex[vertexIdx.x + 3, vertexIdx.y, vertexIdx.z] +
                     vertex[vertexIdx.x - 3, vertexIdx.y, vertexIdx.z])};
}

Preprocessed Scalar
der6y_upwd(in ScalarField vertex)
{
    Scalar inv_ds = AC_inv_dsy;

    return (Scalar){(1.0 / 60.0) * inv_ds *
                    (-20.0 * vertex[vertexIdx.x, vertexIdx.y, vertexIdx.z] +
                     15.0 * (vertex[vertexIdx.x, vertexIdx.y + 1, vertexIdx.z] +
                             vertex[vertexIdx.x, vertexIdx.y - 1, vertexIdx.z]) -
                     6.0 * (vertex[vertexIdx.x, vertexIdx.y + 2, vertexIdx.z] +
                            vertex[vertexIdx.x, vertexIdx.y - 2, vertexIdx.z]) +
                     vertex[vertexIdx.x, vertexIdx.y + 3, vertexIdx.z] +
                     vertex[vertexIdx.x, vertexIdx.y - 3, vertexIdx.z])};
}

Preprocessed Scalar
der6z_upwd(in ScalarField vertex)
{
    Scalar inv_ds = AC_inv_dsz;

    return (Scalar){(1.0 / 60.0) * inv_ds *
                    (-20.0 * vertex[vertexIdx.x, vertexIdx.y, vertexIdx.z] +
                     15.0 * (vertex[vertexIdx.x, vertexIdx.y, vertexIdx.z + 1] +
                             vertex[vertexIdx.x, vertexIdx.y, vertexIdx.z - 1]) -
                     6.0 * (vertex[vertexIdx.x, vertexIdx.y, vertexIdx.z + 2] +
                            vertex[vertexIdx.x, vertexIdx.y, vertexIdx.z - 2]) +
                     vertex[vertexIdx.x, vertexIdx.y, vertexIdx.z + 3] +
                     vertex[vertexIdx.x, vertexIdx.y, vertexIdx.z - 3])};
}

#endif

#if LUPWD
Device Scalar
upwd_der6(in VectorField uu, in ScalarField lnrho)
{
    Scalar uux = fabs(value(uu).x);
    Scalar uuy = fabs(value(uu).y);
    Scalar uuz = fabs(value(uu).z);
    return (Scalar){uux * der6x_upwd(lnrho) + uuy * der6y_upwd(lnrho) + uuz * der6z_upwd(lnrho)};
}
#endif

Device Matrix
gradients(in VectorField uu)
{
    return (Matrix){gradient(uu.x), gradient(uu.y), gradient(uu.z)};
}


Device Scalar
continuity(int3 globalVertexIdx, in VectorField uu, in ScalarField lnrho, Scalar dt)
{
    return -dot(value(uu), gradient(lnrho))
#if LUPWD
           // This is a corrective hyperdiffusion term for upwinding.
           + upwd_der6(uu, lnrho)
#endif
           - divergence(uu);
}

#if LENTROPY
Device Vector
momentum(int3 globalVertexIdx, in VectorField uu, in ScalarField lnrho, in ScalarField ss,
         Scalar dt)
{
    const Matrix S   = stress_tensor(uu);
    const Scalar cs2 = AC_cs2_sound * exp(AC_gamma * value(ss) / AC_cp_sound +
                                          (AC_gamma - 1) * (value(lnrho) - AC_lnrho0));

    // Regex replace CPU constants with get\(AC_([a-zA-Z_0-9]*)\)
    // \1
    const Vector mom = -mul(gradients(uu), value(uu)) -
                       cs2 * ((1.0 / AC_cp_sound) * gradient(ss) + gradient(lnrho)) +
                       AC_nu_visc * (laplace_vec(uu) + (1.0 / 3.0) * gradient_of_divergence(uu) +
                                     2.0 * mul(S, gradient(lnrho))) +
                       AC_zeta * gradient_of_divergence(uu)
        ;
    return mom;
}
#else
Device Vector
momentum(int3 globalVertexIdx, in VectorField uu, in ScalarField lnrho, Scalar dt)
{
    Vector mom;

    const Matrix S = stress_tensor(uu);

    // Isothermal: we have constant speed of sound

    mom = -mul(gradients(uu), value(uu)) - AC_cs2_sound * gradient(lnrho) +
          AC_nu_visc * (laplace_vec(uu) + (1.0 / 3.0) * gradient_of_divergence(uu) +
                        2.0 * mul(S, gradient(lnrho))) +
          AC_zeta * gradient_of_divergence(uu);

    return mom;
}
#endif

Device Vector
induction(in VectorField uu, in VectorField aa)
{
    // Note: We do (-nabla^2 A + nabla(nabla dot A)) instead of (nabla x (nabla
    // x A)) in order to avoid taking the first derivative twice (did the math,
    // yes this actually works. See pg.28 in arXiv:astro-ph/0109497)
    // u cross B - AC_eta * AC_mu0 * (AC_mu0^-1 * [- laplace A + grad div A ])
    const Vector B        = curl(aa);
    //MV: Due to gauge freedom we can reduce the gradient of scalar (divergence) from the equation
    //const Vector grad_div = gradient_of_divergence(aa);
    const Vector lap      = laplace_vec(aa);

    // Note, AC_mu0 is cancelled out
    //MV: Due to gauge freedom we can reduce the gradient of scalar (divergence) from the equation
    //const Vector ind = cross(value(uu), B) - AC_eta * (grad_div - lap);
    const Vector ind = cross(value(uu), B) + AC_eta * lap;

    return ind;
}

#if LENTROPY
Device Scalar
lnT(in ScalarField ss, in ScalarField lnrho)
{
    return AC_lnT0 + AC_gamma * value(ss) / AC_cp_sound +
           (AC_gamma - 1.0) * (value(lnrho) - AC_lnrho0);
}

// Nabla dot (K nabla T) / (rho T)
Device Scalar
heat_conduction(in ScalarField ss, in ScalarField lnrho)
{
    const Scalar inv_AC_cp_sound = 1.0 / AC_cp_sound;

    const Vector grad_ln_chi = -gradient(lnrho);

    const Scalar first_term = AC_gamma * inv_AC_cp_sound * laplace(ss) +
                              (AC_gamma - 1.0) * laplace(lnrho);
    const Vector second_term = AC_gamma * inv_AC_cp_sound * gradient(ss) +
                               (AC_gamma - 1.0) * gradient(lnrho);
    const Vector third_term = AC_gamma * (inv_AC_cp_sound * gradient(ss) + gradient(lnrho)) +
                              grad_ln_chi;

    const Scalar chi = AC_THERMAL_CONDUCTIVITY / (exp(value(lnrho)) * AC_cp_sound);
    return AC_cp_sound * chi * (first_term + dot(second_term, third_term));
}

Device Scalar
heating(const int i, const int j, const int k)
{
    return 1;
}

Device Scalar
entropy(in ScalarField ss, in VectorField uu, in ScalarField lnrho, in VectorField aa)
{
    const Matrix S      = stress_tensor(uu);
    const Scalar inv_pT = 1.0 / (exp(value(lnrho)) * exp(lnT(ss, lnrho)));
    const Vector j      = (1.0 / AC_mu0) *
                     (gradient_of_divergence(aa) - laplace_vec(aa)); // Current density
    const Scalar RHS = H_CONST - C_CONST + AC_eta * (AC_mu0)*dot(j, j) +
                       2.0 * exp(value(lnrho)) * AC_nu_visc * contract(S) +
                       AC_zeta * exp(value(lnrho)) * divergence(uu) * divergence(uu);

    return -dot(value(uu), gradient(ss)) + inv_pT * RHS + heat_conduction(ss, lnrho);
}
#endif

// Declare input and output arrays using locations specified in the
// array enum in astaroth.h
in ScalarField lnrho(VTXBUF_LNRHO);
out ScalarField out_lnrho(VTXBUF_LNRHO);

in VectorField uu(VTXBUF_UUX, VTXBUF_UUY, VTXBUF_UUZ);
out VectorField out_uu(VTXBUF_UUX, VTXBUF_UUY, VTXBUF_UUZ);

#if LENTROPY
in ScalarField ss(VTXBUF_ENTROPY);
out ScalarField out_ss(VTXBUF_ENTROPY);
#endif


Kernel void
solve()
{
    Scalar dt = AC_dt;
    out_lnrho = rk3(out_lnrho, lnrho, continuity(globalVertexIdx, uu, lnrho, dt), dt);

#if LENTROPY
    out_uu = rk3(out_uu, uu, momentum(globalVertexIdx, uu, lnrho, ss, aa, dt), dt);
    out_ss = rk3(out_ss, ss, entropy(ss, uu, lnrho, aa), dt);
#else
    out_uu = rk3(out_uu, uu, momentum(globalVertexIdx, uu, lnrho, dt), dt);
#endif
}
