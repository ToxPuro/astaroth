#include <stdderiv.h>

#define LDENSITY (1)
#define LHYDRO (1)
#define LENERGY (1)

#define LSTUPID (1)
#define LPPM (0)

// Int params
uniform int AC_max_steps;
uniform int AC_save_steps;
uniform int AC_bin_steps;
uniform int AC_start_step;

uniform int AC_bc_type_top_x;
uniform int AC_bc_type_bot_x;
uniform int AC_bc_type_top_y;
uniform int AC_bc_type_bot_y;
uniform int AC_bc_type_top_z;
uniform int AC_bc_type_bot_z;

// Real params
uniform Scalar AC_dt;
uniform Scalar AC_max_time;
// Spacing
uniform Scalar AC_dsmin;
// physical grid
uniform Scalar AC_xlen;
uniform Scalar AC_ylen;
uniform Scalar AC_zlen;
uniform Scalar AC_xorig;
uniform Scalar AC_yorig;
uniform Scalar AC_zorig;
// Physical units
uniform Scalar AC_unit_density;
uniform Scalar AC_unit_velocity;
uniform Scalar AC_unit_length;
uniform Scalar AC_unit_magnetic;
// properties of gravitating star
uniform Scalar AC_star_pos_x;
uniform Scalar AC_star_pos_y;
uniform Scalar AC_star_pos_z;
uniform Scalar AC_M_star;
// properties of sink particle
uniform Scalar AC_sink_pos_x;
uniform Scalar AC_sink_pos_y;
uniform Scalar AC_sink_pos_z;
uniform Scalar AC_M_sink;
uniform Scalar AC_M_sink_init;
uniform Scalar AC_M_sink_Msun;
uniform Scalar AC_soft;
uniform Scalar AC_accretion_range;
uniform Scalar AC_switch_accretion;
//  Run params
uniform Scalar AC_cdt;
uniform Scalar AC_cdtv;
uniform Scalar AC_cdts;
uniform Scalar AC_nu_visc;
uniform Scalar AC_cs_sound = 1.0;
uniform Scalar AC_eta;
uniform Scalar AC_mu0;
uniform Scalar AC_cp_sound;
uniform Scalar AC_gamma;
uniform Scalar AC_cv_sound;
uniform Scalar AC_lnT0;
uniform Scalar AC_lnrho0;
uniform Scalar AC_zeta;
uniform Scalar AC_trans;
//  Other
uniform Scalar AC_bin_save_t;
//  Initial condition params
uniform Scalar AC_ampl_lnrho;
uniform Scalar AC_ampl_uu;
uniform Scalar AC_angl_uu;
uniform Scalar AC_lnrho_edge;
uniform Scalar AC_lnrho_out;
uniform Scalar AC_ampl_aa;
uniform Scalar AC_init_k_wave;
uniform Scalar AC_init_sigma_hel;
//  Forcing parameters. User configured.
uniform Scalar AC_forcing_magnitude;
uniform Scalar AC_relhel;
uniform Scalar AC_kmin;
uniform Scalar AC_kmax;
//  Forcing parameters. Set by the generator.
uniform Scalar AC_forcing_phase;
uniform Scalar AC_k_forcex;
uniform Scalar AC_k_forcey;
uniform Scalar AC_k_forcez;
uniform Scalar AC_kaver;
uniform Scalar AC_ff_hel_rex;
uniform Scalar AC_ff_hel_rey;
uniform Scalar AC_ff_hel_rez;
uniform Scalar AC_ff_hel_imx;
uniform Scalar AC_ff_hel_imy;
uniform Scalar AC_ff_hel_imz;
//  Additional helper params  //  (deduced from other params do not set these directly!)
uniform Scalar AC_G_const;
uniform Scalar AC_GM_star;
uniform Scalar AC_unit_mass;
uniform Scalar AC_sq2GM_star;
uniform Scalar AC_cs2_sound = AC_cs_sound * AC_cs_sound;

/*
 * =============================================================================
 * User-defined vertex buffers
 * =============================================================================
 */
uniform ScalarField VTXBUF_RHO;
uniform ScalarField VTXBUF_RHOUUX;
uniform ScalarField VTXBUF_RHOUUY;
uniform ScalarField VTXBUF_RHOUUZ;
uniform ScalarField VTXBUF_ENERGY;

// Perform the interpolation part at the Preprocessed stage 
Preprocessed Matrix 
interpolate(Scalar direction, in ScalarField vertex)
{
    // interp_LR indexing guide
    // direction = +1            // direction = -1 
    // 0  => x positive, Left   // 0 => x negative, Left
    // 1  => x positive, Right  // 1 => x negative, Right
    // 2  => y positive, Left   // 2 => y negative, Left
    // 3  => y positive, Right  // 3 => y negative, Right
    // 4  => z positive, Left   // 4 => z negative, Left
    // 5  => z positive, Right  // 5 => z negative, Right
   
    Matrix mat;
    
#if LSTUPID
    //Simple ind stupid interpolation. Only for testing purposes
    if (direction > 0.0) 
    {
        // Right Values x, y, z
        mat.row[0] = (Vector){vertex[vertexIdx.x+1, vertexIdx.y  , vertexIdx.z  ], 
                              vertex[vertexIdx.x  , vertexIdx.y+1, vertexIdx.z  ], 
                              vertex[vertexIdx.x  , vertexIdx.y  , vertexIdx.z+1]};
        // Left Values x, y, z
        mat.row[1] = (Vector){vertex[vertexIdx.x  , vertexIdx.y  , vertexIdx.z  ], 
                              vertex[vertexIdx.x  , vertexIdx.y  , vertexIdx.z  ], 
                              vertex[vertexIdx.x  , vertexIdx.y  , vertexIdx.z  ]};
    } 
    else if (direction <= 0.0)
    { 
        // Right Values x, y, z
        mat.row[0] = (Vector){vertex[vertexIdx.x  , vertexIdx.y  , vertexIdx.z  ], 
                              vertex[vertexIdx.x  , vertexIdx.y  , vertexIdx.z  ], 
                              vertex[vertexIdx.x  , vertexIdx.y  , vertexIdx.z  ]};
        // Left Values x, y, z
        mat.row[1] = (Vector){vertex[vertexIdx.x-1, vertexIdx.y  , vertexIdx.z  ], 
                              vertex[vertexIdx.x  , vertexIdx.y-1, vertexIdx.z  ], 
                              vertex[vertexIdx.x  , vertexIdx.y  , vertexIdx.z-1]};
    }
#elif LPPM
    // TODO PPM interpolation
#endif

    return mat;
    
}

// Extact velocity primitives from momentum
Preprocessed Matrix 
get_primitives_velocity(Matrix rho, Matrix rhouu_comp)
{
    Matrix mat;
    
    // Right Values x, y, z
    mat.row[0] = (Vector){rhouu_comp.row[0].x/rho.row[0].x, 
                          rhouu_comp.row[0].y/rho.row[0].y, 
                          rhouu_comp.row[0].z/rho.row[0].z};
    // Left Values x, y, z                                
    mat.row[1] = (Vector){rhouu_comp.row[1].x/rho.row[1].x, 
                          rhouu_comp.row[1].y/rho.row[1].y, 
                          rhouu_comp.row[1].z/rho.row[1].z};

    return mat;
    
}

// Extact velocity primitives from momentum
Preprocessed Matrix 
get_primitives_pressure(Matrix rho, Matrix energy)
{
    Matrix mat;
    
    // Right Values x, y, z
    mat.row[0] = (Vector){(AC_gamma_m1)*rho.row[0].x*energy.row[0].x, 
                          (AC_gamma_m1)*rho.row[0].y*energy.row[0].y, 
                          (AC_gamma_m1)*rho.row[0].z*energy.row[0].z};
    // Left Values x, y, z                                    
    mat.row[1] = (Vector){(AC_gamma_m1)*rho.row[1].x*energy.row[1].x, 
                          (AC_gamma_m1)*rho.row[1].y*energy.row[1].y, 
                          (AC_gamma_m1)*rho.row[1].z*energy.row[1].z};

    return mat;
    
}

Scalar
Roe_hydro_adiabatic_a_1(Roe_uux, Roe_uuy, Roe_uuz, Roe_HH, rhoL, rhoR, rhouuxL, rhouuyR, rhouuyL, rhouuyR, rhouuzL, rhouuzR, energyL, energyR)
{   
    Scalar vv2      = Roe_uux*Roe_uux + Roe_uuy*Roe_uuy + Roe_uuz*Roe_uuz;
    Scalar cs_adiab = AC_gamma_m1*(Roe_HH-vv2/Scalar(2.0));
    Scalar An       = Scalar(1.0)/(Scalar(2.0)*cs_adiab*cs_adiab);

    return An*AC_gamma_m1*( (vv2/Scalar(2.0) + Roe_uux*cs_adiab/AC_gamma_m1)*(rhoL    - rhoR   ) + 
                           -(Roe_uux + cs_adiab/AC_gamma_m1)                *(rhouuxL - rhouuxR) +
                           - Roe_uuy                                        *(rhouuyL - rhouuyR) +
                           - Roe_uuz                                        *(rhouuzL - rhouuzR) +
                           + Scalar(1.0)                                    *(energyL - energyR) 
                          );
} 

Scalar
Roe_hydro_adiabatic_a_2(Roe_uuy, rhoL, rhoR, rhouuxL, rhouuyR)
{   
    return ( - Roe_uuy                                       *(rhoL    - rhoR   ) + 
             + Scalar(1.0)                                   *(rhouuyL - rhouuyR) 
           );
} 

Scalar
Roe_hydro_adiabatic_a_3(Roe_uuz, rhoL, rhoR, rhouuxL, rhouuyR)
{   
    return ( - Roe_uuz                                       *(rhoL    - rhoR   ) + 
             + Scalar(z.0)                                   *(rhouuzL - rhouuzR) 
           );
} 

Scalar
Roe_hydro_adiabatic_a_4(Roe_uux, Roe_uuy, Roe_uuz, Roe_HH, rhoL, rhoR, rhouuxL, rhouuyR, rhouuyL, rhouuyR, rhouuzL, rhouuzR, energyL, energyR)
{   
    Scalar vv2      = Roe_uux*Roe_uux + Roe_uuy*Roe_uuy + Roe_uuz*Roe_uuz;
    Scalar cs_adiab = AC_gamma_m1*(Roe_HH-vv2/Scalar(2.0)); 
    Scalar An       = Scalar(1.0)/(Scalar(2.0)*cs_adiab*cs_adiab);

    return (AC_gamma_m1/(cs_adiab*cs_adiab))*( (cs_adiab*cs_adiab)*(Scalar(1.0)/AC_gamma_m1 - An*vv2)*(rhoL    - rhoR   ) + 
                                              + Roe_uux                                              *(rhouuxL - rhouuxR) +
                                              + Roe_uuy                                              *(rhouuyL - rhouuyR) +
                                              + Roe_uuz                                              *(rhouuzL - rhouuzR) +
                                              - Scalar(1.0)                                          *(energyL - energyR) 
                                             );
} 

Scalar
Roe_hydro_adiabatic_a_5(Roe_uux, Roe_uuy, Roe_uuz, Roe_HH, rhoL, rhoR, rhouuxL, rhouuyR, rhouuyL, rhouuyR, rhouuzL, rhouuzR, energyL, energyR)
{   
    Scalar vv2      = Roe_uux*Roe_uux + Roe_uuy*Roe_uuy + Roe_uuz*Roe_uuz;
    Scalar cs_adiab = AC_gamma_m1*(Roe_HH-vv2/Scalar(2.0));
    Scalar An       = Scalar(1.0)/(Scalar(2.0)*cs_adiab*cs_adiab);

    return An*AC_gamma_m1*( (vv2/Scalar(2.0) - Roe_uux*cs_adiab/AC_gamma_m1)*(rhoL    - rhoR   ) + 
                           -(Roe_uux - cs_adiab/AC_gamma_m1)                *(rhouuxL - rhouuxR) +
                           - Roe_uuy                                        *(rhouuyL - rhouuyR) +
                           - Roe_uuz                                        *(rhouuzL - rhouuzR) +
                           + Scalar(1.0)                                    *(energyL - energyR) 
                          );
}

Scalar
Roe_eigen_lam_1(Roe_uux, Roe_uuy, Roe_uuz, Roe_HH)
{
    Scalar vv2      = Roe_uux*Roe_uux + Roe_uuy*Roe_uuy + Roe_uuz*Roe_uuz;
    Scalar cs_adiab = AC_gamma_m1*(Roe_HH-vv2/Scalar(2.0));

    return (Roe_uux - Roe_uux)
} 
Scalar
Roe_eigen_lam_2(Roe_uux)
{
    return Roe_uux;
} 
Scalar
Roe_eigen_lam_3(Roe_uux)
{
    return Roe_uux;
} 
Scalar
Roe_eigen_lam_4(Roe_uux)
{
    return Roe_uux;
} 
Scalar
Roe_eigen_lam_5(Roe_uux, Roe_uuy, Roe_uuz, Roe_HH)
{
    Scalar vv2      = Roe_uux*Roe_uux + Roe_uuy*Roe_uuy + Roe_uuz*Roe_uuz;
    Scalar cs_adiab = AC_gamma_m1*(Roe_HH-vv2/Scalar(2.0));

    return (Roe_uux + Roe_uux)
} 

Scalar
riemann_continuity(in ScalarField rho, in ScalarField rhouux, in ScalarField rhouuy, in ScalarField rhouuz, in ScalarField energy)
{
    // Interpolate the stencils
    Matrix rho_pos    = interpolate( 1.0, rho);
    Matrix rho_neg    = interpolate(-1.0, rho);
    Matrix rhouux_pos = interpolate( 1.0, rhouux);
    Matrix rhouux_neg = interpolate(-1.0, rhouux);
    Matrix rhouuy_pos = interpolate( 1.0, rhouuy);
    Matrix rhouuy_neg = interpolate(-1.0, rhouuy);
    Matrix rhouuz_pos = interpolate( 1.0, rhouuz);
    Matrix rhouuz_neg = interpolate(-1.0, rhouuz);
    Matrix energy_pos = interpolate( 1.0, energy);
    Matrix energy_neg = interpolate(-1.0, energy);
 
    // Fetch primitives
    Matrix uux_pos = get_primitives_velocity(rho_pos, rhouux_pos)
    Matrix uux_neg = get_primitives_velocity(rho_neg, rhouux_neg)
    Matrix uuy_pos = get_primitives_velocity(rho_pos, rhouuy_pos)
    Matrix uuy_neg = get_primitives_velocity(rho_neg, rhouuy_neg)
    Matrix uuz_pos = get_primitives_velocity(rho_pos, rhouuz_pos)
    Matrix uuz_neg = get_primitives_velocity(rho_neg, rhouuz_neg)
    Matrix pp_pos  = get_primitives_pressure(rho_pos, energy_pos)
    Matrix pp_neg  = get_primitives_pressure(rho_neg, energy_neg)

    // Solve riemann problems. 
    // Roe method 

    // DRAFT FOR SINGLE LEFT-RIGHT BOUNDARY (+x-direction) 

    // MAKE INTO SUBROUTINE KERNEL! 
    Scalar basic_flux_Right = rho_pos.row[0].x
    Scalar basic_flux_Left  = rho_pos.row[1].x

    Scalar Roe_term1 = Roe_hydro_adiabatic_a_1(Roe_uux, Roe_uuy, Roe_uuz, Roe_HH, rhoL, rhoR, rhouuxL, rhouuyR, rhouuyL, rhouuyR, rhouuzL, rhouuzR, energyL, energyR)
                       *abs(Roe_eigen_lam_1(Roe_uux, Roe_uuy, Roe_uuz, Roe_HH));
    Scalar Roe_term2 = Scalar(0.0);
    Scalar Roe_term3 = Scalar(0.0);
    Scalar Roe_term4 = Roe_hydro_adiabatic_a_4(Roe_uux, Roe_uuy, Roe_uuz, Roe_HH, rhoL, rhoR, rhouuxL, rhouuyR, rhouuyL, rhouuyR, rhouuzL, rhouuzR, energyL, energyR)
                       *abs(Roe_eigen_lam_4(Roe_uux));
    Scalar Roe_term5 = Roe_hydro_adiabatic_a_5(Roe_uux, Roe_uuy, Roe_uuz, Roe_HH, rhoL, rhoR, rhouuxL, rhouuyR, rhouuyL, rhouuyR, rhouuzL, rhouuzR, energyL, energyR)
                       *abs(Roe_eigen_lam_5(Roe_uux, Roe_uuy, Roe_uuz, Roe_HH));

    Scalar Roe_term  = Roe_term1 + Roe_term2 + Roe_term3 + Roe_term4 + Roe_term5; 
    
    Scalar flux_roe  = Scalar(0.5)*(basic_flux_Left - basic_flux_Right + Roe_term);

    return flux_roe;   
}


//Device Scalar
//continuity(int3 globalVertexIdx, in VectorField uu, in ScalarField lnrho, Scalar dt)
//{
//    return -dot(value(uu), gradient(lnrho))
//           - divergence(uu);
//}

in ScalarField  rho(VTXBUF_RHO);
out ScalarField out_rho(VTXBUF_RHO);

in  VectorField rhouu(VTXBUF_RHOUUX, VTXBUF_RHOUUY, VTXBUF_RHOUUZ);
out VectorField out_rhouu(VTXBUF_RHOUUX, VTXBUF_RHOUUY, VTXBUF_RHOUUZ);

in ScalarField  energy(VTXBUF_ENERGY);
out ScalarField out_energy(VTXBUF_ENERGY);

Kernel void
solve()
{
    Scalar dt = AC_dt;
    out_lnrho = rk3(out_lnrho, lnrho, continuity(globalVertexIdx, uu, lnrho, dt), dt);
    out_uu = rk3(out_uu, uu, momentum(globalVertexIdx, uu, lnrho, ss, aa, dt), dt);
    out_ss = rk3(out_ss, ss, entropy(ss, uu, lnrho, aa), dt);
    out_uu = rk3(out_uu, uu, momentum(globalVertexIdx, uu, lnrho, dt), dt);

}
