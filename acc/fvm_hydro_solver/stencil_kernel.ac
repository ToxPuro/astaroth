#include <stdderiv.h>

#define LDENSITY (1)
#define LHYDRO (1)
#define LENERGY (1)

#define LSTUPID (1)
#define LPPM (0)

// Int params
uniform int AC_max_steps;
uniform int AC_save_steps;
uniform int AC_bin_steps;
uniform int AC_start_step;

uniform int AC_bc_type_top_x;
uniform int AC_bc_type_bot_x;
uniform int AC_bc_type_top_y;
uniform int AC_bc_type_bot_y;
uniform int AC_bc_type_top_z;
uniform int AC_bc_type_bot_z;

// Real params
uniform Scalar AC_dt;
uniform Scalar AC_max_time;
// Spacing
uniform Scalar AC_dsmin;
// physical grid
uniform Scalar AC_xlen;
uniform Scalar AC_ylen;
uniform Scalar AC_zlen;
uniform Scalar AC_xorig;
uniform Scalar AC_yorig;
uniform Scalar AC_zorig;
// Physical units
uniform Scalar AC_unit_density;
uniform Scalar AC_unit_velocity;
uniform Scalar AC_unit_length;
uniform Scalar AC_unit_magnetic;
// properties of gravitating star
uniform Scalar AC_star_pos_x;
uniform Scalar AC_star_pos_y;
uniform Scalar AC_star_pos_z;
uniform Scalar AC_M_star;
// properties of sink particle
uniform Scalar AC_sink_pos_x;
uniform Scalar AC_sink_pos_y;
uniform Scalar AC_sink_pos_z;
uniform Scalar AC_M_sink;
uniform Scalar AC_M_sink_init;
uniform Scalar AC_M_sink_Msun;
uniform Scalar AC_soft;
uniform Scalar AC_accretion_range;
uniform Scalar AC_switch_accretion;
//  Run params
uniform Scalar AC_cdt;
uniform Scalar AC_cdtv;
uniform Scalar AC_cdts;
uniform Scalar AC_nu_visc;
uniform Scalar AC_cs_sound = 1.0;
uniform Scalar AC_eta;
uniform Scalar AC_mu0;
uniform Scalar AC_cp_sound;
uniform Scalar AC_gamma;
uniform Scalar AC_cv_sound;
uniform Scalar AC_lnT0;
uniform Scalar AC_lnrho0;
uniform Scalar AC_zeta;
uniform Scalar AC_trans;
//  Other
uniform Scalar AC_bin_save_t;
//  Initial condition params
uniform Scalar AC_ampl_lnrho;
uniform Scalar AC_ampl_uu;
uniform Scalar AC_angl_uu;
uniform Scalar AC_lnrho_edge;
uniform Scalar AC_lnrho_out;
uniform Scalar AC_ampl_aa;
uniform Scalar AC_init_k_wave;
uniform Scalar AC_init_sigma_hel;
//  Forcing parameters. User configured.
uniform Scalar AC_forcing_magnitude;
uniform Scalar AC_relhel;
uniform Scalar AC_kmin;
uniform Scalar AC_kmax;
//  Forcing parameters. Set by the generator.
uniform Scalar AC_forcing_phase;
uniform Scalar AC_k_forcex;
uniform Scalar AC_k_forcey;
uniform Scalar AC_k_forcez;
uniform Scalar AC_kaver;
uniform Scalar AC_ff_hel_rex;
uniform Scalar AC_ff_hel_rey;
uniform Scalar AC_ff_hel_rez;
uniform Scalar AC_ff_hel_imx;
uniform Scalar AC_ff_hel_imy;
uniform Scalar AC_ff_hel_imz;
//  Additional helper params  //  (deduced from other params do not set these directly!)
uniform Scalar AC_G_const;
uniform Scalar AC_GM_star;
uniform Scalar AC_unit_mass;
uniform Scalar AC_sq2GM_star;
uniform Scalar AC_cs2_sound = AC_cs_sound * AC_cs_sound;

/*
 * =============================================================================
 * User-defined vertex buffers
 * =============================================================================
 */
uniform ScalarField VTXBUF_RHO;
uniform ScalarField VTXBUF_RHOUUX;
uniform ScalarField VTXBUF_RHOUUY;
uniform ScalarField VTXBUF_RHOUUZ;
uniform ScalarField VTXBUF_ENERGY;

// Perform the interpolation part at the Preprocessed stage 
Preprocessed Matrix 
interpolate(Scalar direction, in ScalarField vertex)
{
    // interp_LR indexing guide
    // direction = +1            // direction = -1 
    // 0  => x positive, Left   // 0 => x negative, Left
    // 1  => x positive, Right  // 1 => x negative, Right
    // 2  => y positive, Left   // 2 => y negative, Left
    // 3  => y positive, Right  // 3 => y negative, Right
    // 4  => z positive, Left   // 4 => z negative, Left
    // 5  => z positive, Right  // 5 => z negative, Right
   
    Matrix mat;
    
#if LSTUPID
    //Simple ind stupid interpolation. Only for testing purposes
    if (direction > 0.0) 
    {
        // Right Values x, y, z
        mat.row[0] = (Vector){vertex[vertexIdx.x+1, vertexIdx.y  , vertexIdx.z  ], 
                              vertex[vertexIdx.x  , vertexIdx.y+1, vertexIdx.z  ], 
                              vertex[vertexIdx.x  , vertexIdx.y  , vertexIdx.z+1]};
        // Left Values x, y, z
        mat.row[1] = (Vector){vertex[vertexIdx.x  , vertexIdx.y  , vertexIdx.z  ], 
                              vertex[vertexIdx.x  , vertexIdx.y  , vertexIdx.z  ], 
                              vertex[vertexIdx.x  , vertexIdx.y  , vertexIdx.z  ]};
    } 
    else if (direction <= 0.0)
    { 
        // Right Values x, y, z
        mat.row[0] = (Vector){vertex[vertexIdx.x  , vertexIdx.y  , vertexIdx.z  ], 
                              vertex[vertexIdx.x  , vertexIdx.y  , vertexIdx.z  ], 
                              vertex[vertexIdx.x  , vertexIdx.y  , vertexIdx.z  ]};
        // Left Values x, y, z
        mat.row[1] = (Vector){vertex[vertexIdx.x-1, vertexIdx.y  , vertexIdx.z  ], 
                              vertex[vertexIdx.x  , vertexIdx.y-1, vertexIdx.z  ], 
                              vertex[vertexIdx.x  , vertexIdx.y  , vertexIdx.z-1]};
    }
#elif LPPM
    // TODO PPM interpolation
#endif

    return ;
    
}

Scalar
riemann_caller(in ScalarField rho, in ScalarField rhouux, in ScalarField rhouuy, in ScalarField rhouuz, in ScalarField energy)
{
    Scalar rho_LR[12], rhouux_LR[12], rhouuy_LR[12], rhouuz_LR[12], energy_LR[12]; // Conserved variables
    Scalar rho_LR[12],    uux_LR[12],    uuy_LR[12],    uuz_LR[12],     pp_LR[12]; // Primitives

    // Interpolate the stencils
    Matrix rho_pos = interpolate( 1.0, rho);
    Matrix rho_neg = interpolate(-1.0, rho);
    
    // Fetch primitives

    // Solve riemann problems. 
    

    return 1.0;   
}


//Preprocessed Scalar
//der6x_upwd(in ScalarField vertex)
//{
//    Scalar inv_ds = AC_inv_dsx;
//
//    return (Scalar){(1.0 / 60.0) * inv_ds *
//                    (-20.0 * vertex[vertexIdx.x, vertexIdx.y, vertexIdx.z] +
//                     15.0 * (vertex[vertexIdx.x + 1, vertexIdx.y, vertexIdx.z] +
//                             vertex[vertexIdx.x - 1, vertexIdx.y, vertexIdx.z]) -
//                     6.0 * (vertex[vertexIdx.x + 2, vertexIdx.y, vertexIdx.z] +
//                            vertex[vertexIdx.x - 2, vertexIdx.y, vertexIdx.z]) +
//                     vertex[vertexIdx.x + 3, vertexIdx.y, vertexIdx.z] +
//                     vertex[vertexIdx.x - 3, vertexIdx.y, vertexIdx.z])};
//}
//
//Device Scalar
//upwd_der6(in VectorField uu, in ScalarField lnrho)
//{
//    Scalar uux = fabs(value(uu).x);
//    Scalar uuy = fabs(value(uu).y);
//    Scalar uuz = fabs(value(uu).z);
//    return (Scalar){uux * der6x_upwd(lnrho) + uuy * der6y_upwd(lnrho) + uuz * der6z_upwd(lnrho)};
//}

//Device Matrix
//gradients(in VectorField uu)
//{
//    return (Matrix){gradient(uu.x), gradient(uu.y), gradient(uu.z)};
//}

Device Scalar
continuity(int3 globalVertexIdx, in VectorField uu, in ScalarField lnrho, Scalar dt)
{
    return -dot(value(uu), gradient(lnrho))
           - divergence(uu);
}

in ScalarField  rho(VTXBUF_RHO);
out ScalarField out_rho(VTXBUF_RHO);

in  VectorField rhouu(VTXBUF_RHOUUX, VTXBUF_RHOUUY, VTXBUF_RHOUUZ);
out VectorField out_rhouu(VTXBUF_RHOUUX, VTXBUF_RHOUUY, VTXBUF_RHOUUZ);

in ScalarField  energy(VTXBUF_ENERGY);
out ScalarField out_energy(VTXBUF_ENERGY);

Kernel void
solve()
{
    Scalar dt = AC_dt;
    out_lnrho = rk3(out_lnrho, lnrho, continuity(globalVertexIdx, uu, lnrho, dt), dt);
    out_uu = rk3(out_uu, uu, momentum(globalVertexIdx, uu, lnrho, ss, aa, dt), dt);
    out_ss = rk3(out_ss, ss, entropy(ss, uu, lnrho, aa), dt);
    out_uu = rk3(out_uu, uu, momentum(globalVertexIdx, uu, lnrho, dt), dt);

}
