#include "../../../acc-runtime/stdlib/general_grid"
#include "../../../acc-runtime/stdlib/general_derivs.h"
#include "../../../acc-runtime/stdlib/math"
#include "../../../acc-runtime/stdlib/bc.h"
#include "../../../acc-runtime/stdlib/general_operators.h"
Field POTENTIAL
Field SPH_UPPER_POTENTIAL
Field SPH_LOWER_POTENTIAL
Field DENSITY
Field ANALYTICAL
Field RESIDUAL

int AC_n_solving_steps = 1000
AcReal AC_power_law_mapping_exponent = 1.0
int AC_charge_radius_points = 10
real AC_density_charge = 0.0

const int AC_n_spherical_harmonics = 6
gmem real AC_PLM[AC_mlocal.y][AC_n_spherical_harmonics][AC_n_spherical_harmonics]
gmem real AC_cos_m_phis[AC_mlocal.z][AC_n_spherical_harmonics]
gmem real AC_sin_m_phis[AC_mlocal.z][AC_n_spherical_harmonics]
global output real AC_upper_positive_MLM[AC_n_spherical_harmonics*AC_n_spherical_harmonics]
global output real AC_upper_negative_MLM[AC_n_spherical_harmonics*AC_n_spherical_harmonics]

global output real AC_lower_positive_MLM[AC_n_spherical_harmonics*AC_n_spherical_harmonics]
global output real AC_lower_negative_MLM[AC_n_spherical_harmonics*AC_n_spherical_harmonics]

//output real AC_MLM[AC_n_spherical_harmonics][AC_n_spherical_harmonics][2]
output real AC_TEST
Field Y_11
Field Y_10
Field Y_20
Field Y_11_ANALYTICAL
Field Y_00
Field Y_00_ANALYTICAL
positive_real_spherical_harmonic(int m, int l)
{
	return AC_PLM[vertexIdx.y][l][m]*AC_cos_m_phis[vertexIdx.z][m]
}

negative_real_spherical_harmonic(int m, int l)
{
	return AC_PLM[vertexIdx.y][l][m]*AC_sin_m_phis[vertexIdx.z][m]
}

Kernel calculate_mlm()
{
	r = AC_r[vertexIdx.x]

	/**
	w_x = 4.0/3.0
	w_y = 4.0/3.0
	w_z = 4.0/3.0
	x_local = vertexIdx.x-NGHOST
	y_local = vertexIdx.y-NGHOST
	z_local = vertexIdx.z-NGHOST
	if(x_local == 0 || x_local == AC_nlocal.x-1) w_x = 1.0/3.0
	else if(x_local % 2 == 1) w_x = 4.0/3.0
	else  w_x = 2.0/3.0


        if(x_local == 0) w_x += 17.0/24.0;
        if(x_local == 1) w_x -= 7.0/24.0;
        if(x_local == 2) w_x += 1.0/12.0;
        if(x_local == AC_nlocal.x-1) w_x += 17.0/24.0;
        if(x_local == AC_nlocal.x-2) w_x -= 7.0/24.0;
        if(x_local == AC_nlocal.x-3) w_x += 1.0/12.0;

	if(y_local == 0 || y_local == AC_nlocal.y-1) w_y = 1.0/3.0
	else if(y_local % 2 == 1) w_y = 4.0/3.0
	else  w_y = 2.0/3.0

        if(y_local == 0) w_y += 17.0/24.0;
        if(y_local == 1) w_y -= 7.0/24.0;
        if(y_local == 2) w_y += 1.0/12.0;
        if(y_local == AC_nlocal.y-1) w_y += 17.0/24.0;
        if(y_local == AC_nlocal.y-2) w_y -= 7.0/24.0;
        if(y_local == AC_nlocal.y-3) w_y += 1.0/12.0;

	if(z_local == 0 || z_local == AC_nlocal.z-1) w_z = 1.0/3.0
	else if(z_local % 2 == 1) w_z = 4.0/3.0
	else  w_z = 2.0/3.0

        if(z_local == 0) w_z += 17.0/24.0;
        if(z_local == 1) w_z -= 7.0/24.0;
        if(z_local == 2) w_z += 1.0/12.0;
        if(z_local == AC_nlocal.z-1) w_z += 17.0/24.0;
        if(z_local == AC_nlocal.z-2) w_z -= 7.0/24.0;
        if(z_local == AC_nlocal.z-3) w_z += 1.0/12.0;
	**/

	//w_x = 1.0
	w = get_integration_weight()

	for l in 0:AC_n_spherical_harmonics
	{
		//Interior potential expansion
		r_factor = 1.0
		for i in 0:l
		{
			r_factor *= r
		}
		for m in 0:l+1
		{
			rest     = DENSITY*r_factor*w
			reduce_sum(positive_real_spherical_harmonic(m,l)*rest,AC_upper_positive_MLM[l + m*AC_n_spherical_harmonics])
			if(m > 0)
			{
				reduce_sum(negative_real_spherical_harmonic(m,l)*rest,AC_upper_negative_MLM[l + m*AC_n_spherical_harmonics])
			}
		}
		//Exterior potential expansion
		r_factor = 1.0
		for i in 0:l+1
		{
			r_factor /= r
		}
		for m in 0:l+1
		{
			rest     = DENSITY*r_factor*w
			reduce_sum(positive_real_spherical_harmonic(m,l)*rest,AC_lower_positive_MLM[l + m*AC_n_spherical_harmonics])
			if(m > 0)
			{
				reduce_sum(negative_real_spherical_harmonic(m,l)*rest,AC_lower_negative_MLM[l + m*AC_n_spherical_harmonics])
			}
		}
	}
}
Kernel calculate_potential_with_mlm()
{
	r = AC_r[vertexIdx.x]

	//Interior potential expansion
	res = 0.0
	for l in 0:AC_n_spherical_harmonics
	{
		r_factor = 1.0/r
		for i in 0:l
		{
			r_factor /= r
		}
		for m in 0:l+1
		{
			res -= r_factor*AC_upper_positive_MLM[l + m*AC_n_spherical_harmonics]*positive_real_spherical_harmonic(m,l)
			if(m > 0)
			{
				res -= r_factor*AC_upper_negative_MLM[l + m*AC_n_spherical_harmonics]*negative_real_spherical_harmonic(m,l)
			}
		}
	}
	write(SPH_UPPER_POTENTIAL,res)

	//Exterior potential expansion
	res = 0.0
	for l in 0:AC_n_spherical_harmonics
	{
		r_factor = 1.0
		for i in 0:l
		{
			r_factor *= r
		}
		for m in 0:l+1
		{
			res -= r_factor*AC_lower_positive_MLM[l + m*AC_n_spherical_harmonics]*positive_real_spherical_harmonic(m,l)
			if(m > 0)
			{
				res -= r_factor*AC_lower_negative_MLM[l + m*AC_n_spherical_harmonics]*negative_real_spherical_harmonic(m,l)
			}
		}
	}
	write(SPH_LOWER_POTENTIAL,res)
}


poisson_laplacian_neighbours(Field f)
{
	return laplace_neighbours(f)
}

jacobi_update()
{
	return (DENSITY-poisson_laplacian_neighbours(POTENTIAL))/laplace_central_coeff()
}
fixed_boundary Kernel jacobi_step_kernel()
{
	write(POTENTIAL,jacobi_update())
}
real AC_SOR_omega
const int RED   = 0
const int BLACK = 1

sor_red_black(int color)
{
	res = (1-AC_SOR_omega)*POTENTIAL +AC_SOR_omega*jacobi_update()
	if((globalVertexIdx.x + globalVertexIdx.y + globalVertexIdx.z) %2 == color)
        {
		write(POTENTIAL,res)
	}
	else
	{
		write(POTENTIAL,POTENTIAL)
	}
}
fixed_boundary Kernel sor_red()
{
	sor_red_black(RED)
}
fixed_boundary Kernel sor_black()
{
	sor_red_black(BLACK)
}
output real AC_residual2
Kernel residual_kernel()
{
	r = laplace_2nd(POTENTIAL)-DENSITY
	reduce_sum(r*r,AC_residual2)
}


Kernel write_residual()
{
	r = laplace_2nd(POTENTIAL)-DENSITY
	write(RESIDUAL,r)
	//Laplace
	/** 
	R_max = grid_position((int3){36,NGHOST,NGHOST}).x
	R_min = grid_position((int3){NGHOST-1,NGHOST,NGHOST}).x
	R = grid_position().x
	B = 1.0/((1.0/R_min) - (1.0/R_max))
	write(ANALYTICAL, -(B/R_max) + (B/R))
	**/
	R = AC_r[AC_charge_radius_points] + 0.5*AC_ds.x
	r_min = AC_r[NGHOST] - 0.5*AC_ds.x
	M_inner = (4.0/3.0)*AC_REAL_PI*AC_density_charge*r_min*r_min*r_min
	potential_missing_from_inner = M_inner*(r*r-3*r_min*r_min)/(2*r_min*r_min*r_min)
	r = AC_r[vertexIdx.x]
	M = (4.0/3.0)*AC_REAL_PI*AC_density_charge*R*R*R
	if(vertexIdx.x <= AC_charge_radius_points)
	{
		write(ANALYTICAL,(M*(r*r-3*R*R)/(2*R*R*R)) - potential_missing_from_inner)
	}
	else
	{
		write(ANALYTICAL,(-M/r) + potential_missing_from_inner)
	}
}

real AC_k = 2.0
Kernel init()
{
	pos = grid_position()
	if(AC_coordinate_system == AC_CARTESIAN_COORDINATES)
	{
		write(DENSITY,sin(AC_k*AC_REAL_PI*pos.x)*sin(AC_k*AC_REAL_PI*pos.y))
	}
        //Diract delta on the first shell
	/**
	else
	{
	  if(globalVertexIdx.x == NGHOST)
	  {
	  	write(DENSITY,AC_density_charge/(4.0*AC_REAL_PI*pos.x*pos.x*AC_ds.x))
	  }
	  else
	  {
	  	write(DENSITY,0.0)
	  }
	}
	**/
	//Constant density on the sphere of radius R where R = AC_r[AC_charge_radius_points]
	if(globalVertexIdx.x <= AC_charge_radius_points)
	{
		write(DENSITY,4*AC_REAL_PI*AC_density_charge)
	}
	else
	{
		write(DENSITY,0.0)
	}
	write(POTENTIAL,0.0)
}
BoundConds bcs
{
	periodic(BOUNDARY_XYZ)
}

ComputeSteps
initcond(bcs)
{
	init()
}


analytic_potential_inside(Field f)
{
        const int3 normal = get_normal()
        const int3 boundary = get_boundary(normal)
        int3 domain = boundary
        int3 ghost  = boundary
	R = AC_r[AC_charge_radius_points]
	M = (4.0/3.0)*AC_REAL_PI*AC_density_charge*R*R*R
        for i in 0:NGHOST
        {
                domain = domain - normal
                ghost  = ghost  + normal
		r = grid_position(ghost).x
		//Laplace
                //f[ghost.x][ghost.y][ghost.z] = 1.0;
		//Shell
                //f[ghost.x][ghost.y][ghost.z] = 1.0/AC_first_gridpoint.x;
		//Sphere
		f[ghost.x][ghost.y][ghost.z] = M*(r*r-3*R*R)/(2*R*R*R)
        }
}

analytic_potential_outside(Field f)
{
        const int3 normal = get_normal()
        const int3 boundary = get_boundary(normal)
        int3 domain = boundary
        int3 ghost  = boundary
	R = AC_r[AC_charge_radius_points]
	M = (4.0/3.0)*AC_REAL_PI*AC_density_charge*R*R*R
        for i in 0:NGHOST
        {
                domain = domain - normal
                ghost  = ghost  + normal
		r = grid_position(ghost).x
		//Laplace
                //f[ghost.x][ghost.y][ghost.z] = 0.0;
		//Shell
                //f[ghost.x][ghost.y][ghost.z] = 1.0/grid_position().x
		//Sphere
		f[ghost.x][ghost.y][ghost.z] = -M/r
        }
}
BoundConds jacobi_bcs
{
	analytic_potential_inside(BOUNDARY_X_BOT,POTENTIAL)
	analytic_potential_outside(BOUNDARY_X_TOP,POTENTIAL)
	ac_bc_sym(BOUNDARY_Y,POTENTIAL,1)
	periodic(BOUNDARY_Z)
	//Cartesian 
	//periodic(BOUNDARY_XYZ)
}

ComputeSteps
jacobi_step(jacobi_bcs)
{
	jacobi_step_kernel()
}

ComputeSteps
sor_red_black_step(jacobi_bcs)
{
	sor_red()
	sor_black()
}
ComputeSteps
sor_red_step(jacobi_bcs)
{
	sor_red()
}
ComputeSteps
sor_black_step(jacobi_bcs)
{
	sor_black()
}
ComputeSteps
get_residual(jacobi_bcs)
{
	residual_kernel()
	write_residual()
}
ComputeSteps
get_potential_with_sph(jacobi_bcs)
{
	calculate_mlm()
	calculate_potential_with_mlm()
}
