#include "../../../acc-runtime/stdlib/bc.h"
int3 AC_unit_halo = (int3){1,1,1}
communicated auxiliary halo(AC_unit_halo) Field QRAD

communicated auxiliary halo(AC_unit_halo) Field Q_PPP
communicated auxiliary halo(AC_unit_halo) Field Q_ZPP
communicated auxiliary halo(AC_unit_halo) Field Q_MPP

communicated auxiliary halo(AC_unit_halo) Field Q_PZP
communicated auxiliary halo(AC_unit_halo) Field Q_ZZP
communicated auxiliary halo(AC_unit_halo) Field Q_MZP

communicated auxiliary halo(AC_unit_halo) Field Q_PMP
communicated auxiliary halo(AC_unit_halo) Field Q_ZMP
communicated auxiliary halo(AC_unit_halo) Field Q_MMP

#define Q_PPM  Q_PPP
#define Q_ZPM  Q_ZPP
#define Q_MPM  Q_MPP
#
#define Q_PZM   Q_PZP
#define Q_ZZM   Q_ZZP
#define Q_MZM   Q_MZP
#
#define Q_PMM   Q_PMP
#define Q_ZMM   Q_ZMP
#define Q_MMM   Q_MMP
#
#define Q_PPZ  Q_PPP
#define Q_ZPZ  Q_ZPP
#define Q_MPZ  Q_MPP
#
#define Q_PZZ   Q_PZP
#define Q_ZZZ   Q_ZZP
#define Q_MZZ   Q_MZP
#
#define Q_PMZ   Q_PMP
#define Q_ZMZ   Q_ZMP
#define Q_MMZ   Q_MMP


communicated auxiliary halo(AC_unit_halo) Field TAU_PPP
communicated auxiliary halo(AC_unit_halo) Field TAU_ZPP
communicated auxiliary halo(AC_unit_halo) Field TAU_MPP

communicated auxiliary halo(AC_unit_halo) Field TAU_PZP
communicated auxiliary halo(AC_unit_halo) Field TAU_ZZP
communicated auxiliary halo(AC_unit_halo) Field TAU_MZP

communicated auxiliary halo(AC_unit_halo) Field TAU_PMP
communicated auxiliary halo(AC_unit_halo) Field TAU_ZMP
communicated auxiliary halo(AC_unit_halo) Field TAU_MMP

#define TAU_PPM  TAU_PPP
#define TAU_ZPM  TAU_ZPP
#define TAU_MPM  TAU_MPP

#define TAU_PZM   TAU_PZP
#define TAU_ZZM   TAU_ZZP
#define TAU_MZM   TAU_MZP
#
#define TAU_PMM   TAU_PMP
#define TAU_ZMM   TAU_ZMP
#define TAU_MMM   TAU_MMP
#
#define TAU_PPZ  TAU_PPP
#define TAU_ZPZ  TAU_ZPP
#define TAU_MPZ  TAU_MPP
#
#define TAU_PZZ   TAU_PZP
#define TAU_ZZZ   TAU_ZZP
#define TAU_MZZ   TAU_MZP
#
#define TAU_PMZ   TAU_PMP
#define TAU_ZMZ   TAU_ZMP
#define TAU_MMZ   TAU_MMP

const Field Q_RAYS = [
			Q_MMM,
			Q_ZMM,
			Q_PMM,

			Q_MZM,
			Q_ZZM,
			Q_PZM,

			Q_MPM,
			Q_ZPM,
			Q_PPM,

			Q_MMZ,
			Q_ZMZ,
			Q_PMZ,

			Q_MZZ,
			Q_ZZZ,
			Q_PZZ,

			Q_MPZ,
			Q_ZPZ,
			Q_PPZ,

			Q_MMP,
			Q_ZMP,
			Q_PMP,

			Q_MZP,
			Q_ZZP,
			Q_PZP,

			Q_MPP,
			Q_ZPP,
			Q_PPP
		     ]

const Field TAU_RAYS = [
			TAU_MMM,
			TAU_ZMM,
			TAU_PMM,

			TAU_MZM,
			TAU_ZZM,
			TAU_PZM,

			TAU_MPM,
			TAU_ZPM,
			TAU_PPM,

			TAU_MMZ,
			TAU_ZMZ,
			TAU_PMZ,

			TAU_MZZ,
			TAU_ZZZ,
			TAU_PZZ,

			TAU_MPZ,
			TAU_ZPZ,
			TAU_PPZ,

			TAU_MMP,
			TAU_ZMP,
			TAU_PMP,

			TAU_MZP,
			TAU_ZZP,
			TAU_PZP,

			TAU_MPP,
			TAU_ZPP,
			TAU_PPP
		     ]

communicated auxiliary Field KAPPA_RHO,SRAD
empty_kernel()
{
}


BoundConds bcs
{
	ac_const_bc(BOUNDARY_XYZ,QRAD,1.0)
	ac_const_bc(BOUNDARY_XYZ,KAPPA_RHO,1.0)
	ac_const_bc(BOUNDARY_XYZ,SRAD,1.0)
	ac_const_bc(BOUNDARY_XYZ,Q_RAYS,1.0)
	ac_const_bc(BOUNDARY_XYZ,TAU_RAYS,1.0)
}

Raytrace (+0,+0,-1) backwards_ray
Raytrace (+0,+0,+1) forwards_ray
Raytrace (-1,+0,+0) left_ray
Raytrace (+1,+0,+0) right_ray
Raytrace (+0,-1,+0) down_ray
Raytrace (+0,+1,+0) up_ray


//Positive Z direction
Raytrace (+1,+1,+1) ppp_ray
Raytrace (+0,+1,+1) zpp_ray
Raytrace (-1,+1,+1) mpp_ray

Raytrace (+1,+0,+1) pzp_ray
Raytrace (+0,+0,+1) zzp_ray
Raytrace (-1,+0,+1) mzp_ray

Raytrace (+1,-1,+1) pmp_ray
Raytrace (+0,-1,+1) zmp_ray
Raytrace (-1,-1,+1) mmp_ray

//Negative Z direction
Raytrace (+1,+1,-1) ppm_ray
Raytrace (+0,+1,-1) zpm_ray
Raytrace (-1,+1,-1) mpm_ray

Raytrace (+1,+0,-1) pzm_ray
Raytrace (+0,+0,-1) zzm_ray
Raytrace (-1,+0,-1) mzm_ray

Raytrace (+1,-1,-1) pmm_ray
Raytrace (+0,-1,-1) zmm_ray
Raytrace (-1,-1,-1) mmm_ray

//Positive Y direction
Raytrace (+1,+1,+0) ppz_ray
Raytrace (+0,+1,+0) zpz_ray
Raytrace (-1,+1,+0) mpz_ray

//Negative Y direction
Raytrace (+1,-1,+0) pmz_ray
Raytrace (+0,-1,+0) zmz_ray
Raytrace (-1,-1,+0) mmz_ray


//Positive X direction
Raytrace (+1,+0,+0) pzz_ray
//Negative X direction
Raytrace (-1,+0,+0) mzz_ray

get_ray_index(int3 direction)
{
	return (direction.x+1)+3*(direction.y+1 + 3*(direction.z+1))
}
get_Q(int3 direction)
{
	return Q_RAYS[get_ray_index(direction)]
}

get_tau(int3 direction)
{
	return TAU_RAYS[get_ray_index(direction)]
}

outgoing_ray(Field f, int3 direction)
{
	if(direction == (int3){+1,+1,+1}) return outgoing_ppp_ray(f)
	if(direction == (int3){-1,+1,+1}) return outgoing_mpp_ray(f)
	if(direction == (int3){+0,+1,+1}) return outgoing_zpp_ray(f)

	if(direction == (int3){+1,+0,+1}) return outgoing_pzp_ray(f)
	if(direction == (int3){-1,+0,+1}) return outgoing_mzp_ray(f)
	if(direction == (int3){+0,+0,+1}) return outgoing_zzp_ray(f)

	if(direction == (int3){+1,-1,+1}) return outgoing_pmp_ray(f)
	if(direction == (int3){-1,-1,+1}) return outgoing_mmp_ray(f)
	if(direction == (int3){+0,-1,+1}) return outgoing_zmp_ray(f)

	if(direction == (int3){+1,+1,-1}) return outgoing_ppp_ray(f)
	if(direction == (int3){-1,+1,-1}) return outgoing_mpp_ray(f)
	if(direction == (int3){+0,+1,-1}) return outgoing_zpp_ray(f)

	if(direction == (int3){+1,+0,-1}) return outgoing_pzp_ray(f)
	if(direction == (int3){-1,+0,-1}) return outgoing_mzp_ray(f)
	if(direction == (int3){+0,+0,-1}) return outgoing_zzp_ray(f)

	if(direction == (int3){+1,-1,-1}) return outgoing_pmp_ray(f)
	if(direction == (int3){-1,-1,-1}) return outgoing_mmp_ray(f)
	if(direction == (int3){+0,-1,-1}) return outgoing_zmp_ray(f)

	if(direction == (int3){+1,+1,+0}) return outgoing_ppz_ray(f)
	if(direction == (int3){-1,+1,+0}) return outgoing_mpz_ray(f)
	if(direction == (int3){+0,+1,+0}) return outgoing_zpz_ray(f)

	if(direction == (int3){+1,-1,+0}) return outgoing_pmz_ray(f)
	if(direction == (int3){-1,-1,+0}) return outgoing_mmz_ray(f)
	if(direction == (int3){+0,-1,+0}) return outgoing_zmz_ray(f)

	if(direction == (int3){+1,+0,+0}) return outgoing_pzz_ray(f)
	if(direction == (int3){-1,+0,+0}) return outgoing_mzz_ray(f)
	return 0.0;
}
incoming_ray(Field f, int3 direction)
{
	if(direction == (int3){+1,+1,+1}) return incoming_ppp_ray(f)
	if(direction == (int3){-1,+1,+1}) return incoming_mpp_ray(f)
	if(direction == (int3){+0,+1,+1}) return incoming_zpp_ray(f)

	if(direction == (int3){+1,+0,+1}) return incoming_pzp_ray(f)
	if(direction == (int3){-1,+0,+1}) return incoming_mzp_ray(f)
	if(direction == (int3){+0,+0,+1}) return incoming_zzp_ray(f)

	if(direction == (int3){+1,-1,+1}) return incoming_pmp_ray(f)
	if(direction == (int3){-1,-1,+1}) return incoming_mmp_ray(f)
	if(direction == (int3){+0,-1,+1}) return incoming_zmp_ray(f)

	if(direction == (int3){+1,+1,-1}) return incoming_ppp_ray(f)
	if(direction == (int3){-1,+1,-1}) return incoming_mpp_ray(f)
	if(direction == (int3){+0,+1,-1}) return incoming_zpp_ray(f)

	if(direction == (int3){+1,+0,-1}) return incoming_pzp_ray(f)
	if(direction == (int3){-1,+0,-1}) return incoming_mzp_ray(f)
	if(direction == (int3){+0,+0,-1}) return incoming_zzp_ray(f)

	if(direction == (int3){+1,-1,-1}) return incoming_pmp_ray(f)
	if(direction == (int3){-1,-1,-1}) return incoming_mmp_ray(f)
	if(direction == (int3){+0,-1,-1}) return incoming_zmp_ray(f)

	if(direction == (int3){+1,+1,+0}) return incoming_ppz_ray(f)
	if(direction == (int3){-1,+1,+0}) return incoming_mpz_ray(f)
	if(direction == (int3){+0,+1,+0}) return incoming_zpz_ray(f)

	if(direction == (int3){+1,-1,+0}) return incoming_pmz_ray(f)
	if(direction == (int3){-1,-1,+0}) return incoming_mmz_ray(f)
	if(direction == (int3){+0,-1,+0}) return incoming_zmz_ray(f)

	if(direction == (int3){+1,+0,+0}) return incoming_pzz_ray(f)
	if(direction == (int3){-1,+0,+0}) return incoming_mzz_ray(f)
	return 0.0;
}

Kernel backwards_rays()
{
	real incoming_value = incoming_backwards_ray(QRAD)
	write(QRAD,incoming_value+1.0)
}

Kernel forwards_rays()
{
	real incoming_value = incoming_forwards_ray(QRAD)
	write(QRAD,incoming_value+1.0)
}

Kernel left_rays()
{
	real incoming_value = incoming_left_ray(QRAD)
	write(QRAD,incoming_value+1.0)
}

Kernel right_rays()
{
	real incoming_value = incoming_right_ray(QRAD)
	write(QRAD,incoming_value+1.0)
}

Kernel down_rays()
{
	real incoming_value = incoming_down_ray(QRAD)
	write(QRAD,incoming_value+1.0)
}

Kernel up_rays()
{
	real incoming_value = incoming_up_ray(QRAD)
	write(QRAD,incoming_value+1.0)
}

Kernel ppp_rays()
{
	real incoming_value = incoming_ppp_ray(QRAD)
	write(QRAD,incoming_value+1.0)
}

Kernel nine_rays()
{
	write(Q_PPP,incoming_ppp_ray(Q_PPP)+1.0)
	write(Q_ZPP,incoming_zpp_ray(Q_ZPP)+1.0)
	write(Q_MPP,incoming_mpp_ray(Q_MPP)+1.0)

	write(Q_PZP,incoming_pzp_ray(Q_PZP)+1.0)
	write(Q_ZZP,incoming_zzp_ray(Q_ZZP)+1.0)
	write(Q_MZP,incoming_mzp_ray(Q_MZP)+1.0)

	write(Q_PMP,incoming_pmp_ray(Q_PMP)+1.0)
	write(Q_ZMP,incoming_zmp_ray(Q_ZMP)+1.0)
	write(Q_MMP,incoming_mmp_ray(Q_MMP)+1.0)
}

incoming_ray_length(int3 direction)
{
	return sqrt(
		 	  abs(direction.x)*AC_ds_2.x
			+ abs(direction.y)*AC_ds_2.y
			+ abs(direction.z)*AC_ds_2.z
		   )
}
outgoing_ray_length(int3 direction)
{
	return sqrt(
		 	  abs(direction.x)*AC_ds_2.x
			+ abs(direction.y)*AC_ds_2.y
			+ abs(direction.z)*AC_ds_2.z
		   )
}
ray_func(int3 direction)
{
	in_len  = incoming_ray_length(direction)
	out_len = outgoing_ray_length(direction)
	dtau_m = sqrt(incoming_ray(KAPPA_RHO,direction)*KAPPA_RHO)*in_len
	dtau_p = sqrt(outgoing_ray(KAPPA_RHO,direction)*KAPPA_RHO)*out_len

	dSdtau_m = (SRAD - incoming_ray(SRAD,direction))*in_len
	dSdtau_p = (outgoing_ray(SRAD,direction)- SRAD)*out_len

        Srad1st=(dSdtau_p*dtau_m+dSdtau_m*dtau_p)/(dtau_m+dtau_p)
        Srad2nd=2.0*(dSdtau_p-dSdtau_m)/(dtau_m+dtau_p)

	Field Q   = get_Q(direction)
	Field tau = get_tau(direction)
	write(tau,incoming_ray(tau,direction)+dtau_m)

        emdtau=exp(-dtau_m)
        emdtau1=1.0-emdtau
        emdtau2=emdtau*(1.0+dtau_m)-1.0
	write(Q,incoming_ray(Q,direction)+emdtau-Srad1st*emdtau1-Srad2nd*emdtau2)
}

Kernel right_ray_general()
{
	ray_func((int3){1,0,0})
}
ComputeSteps trace_right_ray_general(bcs)
{
	right_ray_general()
}

Kernel nine_rays_general()
{
	for x in -1:+2
	{
		for y in -1:2
		{
			const int3 direction = (int3){x,y,+1}
			ray_func(direction)
		}
	}
}

Kernel three_rays()
{
	write(Q_PPZ,incoming_ppz_ray(Q_PPZ)+1.0)
	write(Q_ZPZ,incoming_zpz_ray(Q_ZPZ)+1.0)
	write(Q_MPZ,incoming_mpz_ray(Q_MPZ)+1.0)
}

Kernel three_rays_general()
{
	for x in -1:2
	{
		const int3 direction = (int3){x,+1,0}
		ray_func(direction)
	}
}

Kernel up_general()
{
	const int3 direction = (int3){0,+1,0}
	ray_func(direction)
}

Kernel baseline_kernel()
{
	write(Q_PPP,Q_PPP*2.0)
	write(Q_ZPP,Q_ZPP*2.0)
	write(Q_MPP,Q_MPP*2.0)

	write(Q_PZP,Q_PZP*2.0)
	write(Q_ZZP,Q_ZZP*2.0)
	write(Q_MZP,Q_MZP*2.0)

	write(Q_PMP,Q_PMP*2.0)
	write(Q_ZMP,Q_ZMP*2.0)
	write(Q_MMP,Q_MMP*2.0)
}

Kernel baseline_y_kernel()
{
	write(Q_PPZ,Q_PPZ*2.0)
	write(Q_ZPZ,Q_ZPZ*2.0)
	write(Q_MPZ,Q_MPZ*2.0)
}

get_incoming_boundary_ray_point(int3 direction)
{
	const int steps_x = (direction.x > 0) ? vertexIdx.x-NGHOST :
		      (direction.x < 0) ? AC_nlocal_max.x - vertexIdx.x
					: INT_MAX
	const int steps_y = (direction.y > 0) ? vertexIdx.y-NGHOST :
		      (direction.y < 0) ? AC_nlocal_max.y - vertexIdx.y
					: INT_MAX
	const int steps_z = (direction.z > 0) ? vertexIdx.z-NGHOST :
		      (direction.z < 0) ? AC_nlocal_max.z - vertexIdx.z
					: INT_MAX
	const int steps = min(steps_x,min(steps_y,steps_z))
	return (int3)
		{
			vertexIdx.x-steps*direction.x,
			vertexIdx.y-steps*direction.y,
			vertexIdx.z-steps*direction.z
		}
}

get_incoming_boundary_ray(Field f, int3 direction)
{
	const int3 boundary_vertex = get_incoming_boundary_ray_point(direction)
	return f[boundary_vertex.x][boundary_vertex.y][boundary_vertex.z]
}

extrinsic_update(int3 direction)
{
	Q = get_Q(direction)
	tau = get_tau(direction)
	incoming_Q = get_incoming_boundary_ray(Q,direction)
	return Q + incoming_Q*exp(-tau)
}

extrinsic_update_along_ray(int3 direction)
{
	Q = get_Q(direction)
	tau = get_tau(direction)
	incoming_Q = incoming_ray(Q,direction)
	revised_value = Q + incoming_Q*exp(-tau)
	//We don't need this copy of Q anymore so we reuse it to store the incoming ray from the boundary
	write(Q,incoming_Q)
	return revised_value
}


Kernel boundary_revision()
{
	update = 0.0
	for y in -1:2
	{
		const int3 direction = (int3){0,y,+1}
		update += extrinsic_update(direction)
	}
	write(QRAD,update)
}

Kernel nine_rays_revision_along_ray()
{
	update = 0.0
	for x in -1:+2
	{
		if(x == 0) continue
		for y in -1:2
		{
			const int3 direction = (int3){x,y,+1}
			update += extrinsic_update_along_ray(direction)
		}
	}
	write(QRAD,update)
}

Kernel nine_rays_revision()
{
	update = 0.0
	for x in -1:+2
	{
		if(x == 0) continue
		for y in -1:2
		{
			const int3 direction = (int3){x,y,+1}
			update += extrinsic_update(direction)
		}
	}
	write(QRAD,update)
}

ComputeSteps trace_backwards_rays(bcs)
{
	backwards_rays()
}

ComputeSteps trace_forwards_rays(bcs)
{
	forwards_rays()
}

ComputeSteps trace_right_rays(bcs)
{
	right_rays()
}

ComputeSteps trace_left_rays(bcs)
{
	left_rays()
}

ComputeSteps trace_up_rays(bcs)
{
	up_rays()
}

ComputeSteps trace_down_rays(bcs)
{
	down_rays()
}

ComputeSteps trace_ppp_rays(bcs)
{
	ppp_rays()
}

ComputeSteps trace_nine_rays(bcs)
{
	nine_rays()
}

ComputeSteps trace_nine_rays_general(bcs)
{
	nine_rays_general()
}

ComputeSteps revise_boundary_ray(bcs)
{
	boundary_revision()
}

ComputeSteps revise_nine_rays(bcs)
{
	nine_rays_revision()
}

ComputeSteps revise_nine_rays_along_ray(bcs)
{
	nine_rays_revision_along_ray()
}


ComputeSteps trace_three_rays(bcs)
{
	three_rays()
}

ComputeSteps trace_three_rays_general(bcs)
{
	three_rays_general()
}

ComputeSteps trace_up_general(bcs)
{
	up_general()
}

ComputeSteps baseline(bcs)
{
	baseline_kernel()
}

ComputeSteps baseline_y(bcs)
{
	baseline_y_kernel()
}
