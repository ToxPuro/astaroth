#include "../../stdlib/integrators.h"
#include "../../stdlib/math"
#include "../../stdlib/grid.h"
#include "../../stdlib/derivs.h"
#include "../../stdlib/operators.h"
#
const int AC_2d_ints = [[1,2,3], [2,3,4]]
const int AC_const_ints = [1,2,3]
const int AC_const_ints_len = 3
const real AC_const_real = 2.0
const int AC_const_int = 3
const int3 AC_const_int3 = {1,2,3}


enum IHEATCOND
{
	NOTHING,
	K_const,
	SOMETHING
} 

struct TimeParams
{
        real dt;
        real current_time;
}

struct EnumParams
{
	bool test;
	IHEATCOND heatcond;
}  
enum TOP_BOT
{
	AC_top,
	AC_bot	
}
#define NO (0)
#if NO
#include "rubbish"
#endif


const real AC_const_reals = [1.0,2,0,3.0]

const bool AC_const_bool = false
const bool AC_const_bool_true = true
const bool AC_const_bool_arr = [true,false]
//const int AC_first = 1, AC_second = 2
const int AC_first = 2
const int AC_second = 2
const bool AC_first_bool = false, AC_second_bool = true
const bool AC_first_bool_arr = [false,false], AC_third_bool= true

dconst real4 AC_real_4
dconst complex AC_complex_dconst
const real3 AC_const_real3 = {1.0, 2.0, 3.0}
const real3 AC_const_real3_arr = [ {1.0, 2.0, 3.0}, {1.0, 2.0, 3.0}]
const real3 AC_const_real3_arr_2 = [AC_const_real3, AC_const_real3]

const int AC_nx_const = 22
const int AC_ny_const = 22

gmem real AC_real_gmem_arr[AC_nx]
//gmem real AC_gmem_const_dims[AC_nx_const][AC_ny]
gmem real AC_gmem_const_dims[AC_nx_const][AC_ny_const]

gmem real3 AC_real3_gmem_arr[AC_nx]




int AC_2d_int[AC_const_int][AC_const_int*2]

int AC_step_number
real AC_dt

/*
real AC_gamma, AC_nu_visc, AC_zeta, AC_eta
real AC_lnrho0, AC_mu0, AC_lnT0
*/
// Note: not used by mhdsolver.ac at the moment (src/utils/modelsolver.c does)
hostdefine AC_INTEGRATION_ENABLED // Enables acIntegrate() and other non-generic library functions
hostdefine LDENSITY (1)
hostdefine LHYDRO (1)
hostdefine LMAGNETIC (1)
hostdefine LENTROPY (1)
hostdefine LTEMPERATURE (0)
hostdefine LFORCING (0)
hostdefine LUPWD (1)
hostdefine LSINK (0)
hostdefine LBFIELD (1 && LMAGNETIC) // bfield only relevant if magnetic is on
hostdefine LSHOCK (0)
//hostdefine AC_THERMAL_CONDUCTIVITY (0.001) // Now a config parameter, AC_K_heatcond, as it should be. 
hostdefine R_PI (AC_REAL_PI)

// Enables a set of special reductions. Currently for primarily for testing
// purposes:  
hostdefine LSPECIAL_REDUCTIONS (0)  

Field VTXBUF_LNRHO, VTXBUF_UUX, VTXBUF_UUY, VTXBUF_UUZ
//const int NCHEM=20
//Field CHEMISTRY[NCHEM]


#if LMAGNETIC
Field VTXBUF_AX, VTXBUF_AY, VTXBUF_AZ
#endif

#if LENTROPY 
Field VTXBUF_ENTROPY
#endif

const int AC_const_int_2nd = 4
//const int NGHOST_VAL = 3
//Field CHEMISTRY_FIELDS[5]


#if LBFIELD
auxiliary Field BFIELDX
auxiliary Field BFIELDY
auxiliary Field BFIELDZ
const Field3 BFIELD = Field3(BFIELDX,BFIELDY,BFIELDZ)
#endif

#if LSHOCK 
Field VTXBUF_SHOCK
#endif

// Additional params needed by standalone & standalone_mpi
// diagnostics period
int AC_save_steps

// snapshot period
int AC_bin_steps
real AC_bin_save_t

// slices output period
int AC_slice_steps
real AC_slice_save_t

// maximun number of time snapshots during runtime 
// Set AC_num_snapshots < 0 for unlimited snapshots
int AC_num_snapshots

// max simulation time
int AC_max_steps
real AC_max_time

// Forcing parameter generation period (if forcing is on)
int AC_forcing_period_steps
real AC_forcing_period_t

// Initial time step index, default should be 0
int AC_start_step


run_const real  AC_runtime_real_arr[4]
run_const int   AC_runtime_int_arr[2]

run_const bool  AC_runtime_bool_arr[2]

run_const int   AC_runtime_int
run_const real  AC_runtime_real
run_const int3  AC_runtime_int3
run_const real3 AC_runtime_real3
run_const bool  AC_lspherical_coords

// Real params
// Spacing
real AC_dsmin
// physical grid
real AC_xlen
real AC_ylen
real AC_zlen
real AC_xorig
real AC_yorig
real AC_zorig
// Physical units
real AC_unit_density
real AC_unit_velocity
real AC_unit_length
real AC_unit_magnetic
// properties of gravitating star
real AC_star_pos_x
real AC_star_pos_y
real AC_star_pos_z
real AC_M_star
// properties of sink particle
real AC_sink_pos_x
real AC_sink_pos_y
real AC_sink_pos_z
real AC_M_sink
real AC_M_sink_init
real AC_M_sink_Msun
real AC_soft
real AC_accretion_range
real AC_switch_accretion
//  Run params
run_const real AC_cdt
run_const real AC_cdtv
run_const real AC_cdts
run_const real AC_nu_visc
run_const real AC_cs_sound
run_const real AC_eta
run_const real AC_mu0
run_const real AC_cp_sound
run_const real AC_cp
run_const real AC_cv
run_const real AC_gamma
run_const real AC_cv_sound
run_const real AC_lnT0
run_const real AC_lnrho0
run_const real AC_zeta
run_const real AC_trans
run_const real AC_nu_shock
run_const real AC_K_heatcond

//  Parameters for generic boundary conditions, this is a dummy variable for testing, please use different ones for each field
real AC_boundary_derivative

//  Parameters only used in boundary conditions at the moment
//  If you feel they should be elsewhere, please move them
real AC_hcond0_kramers
real AC_hflux
real AC_n_kramers
real AC_sigma_SBt
real AC_chi
real AC_chi_t
real AC_chi_t_prof1

//  Initial condition params
real AC_ampl_lnrho
real AC_ampl_uu
real AC_init_ampl_uu
real AC_angl_uu
real AC_lnrho_edge
real AC_lnrho_out
real AC_ampl_aa
real AC_init_k_wave
real AC_init_sigma_hel
real AC_init_shell_radius
real AC_init_shell_width
//  Forcing parameters. User configured.
real AC_forcing_magnitude
real AC_relhel
real AC_kmin
real AC_kmax
real AC_switch_forcing
//  Forcing parameters. Set by the generator.
real AC_forcing_phase
real AC_k_forcex
real AC_k_forcey
real AC_k_forcez
real AC_kaver
real AC_ff_hel_rex
real AC_ff_hel_rey
real AC_ff_hel_rez
real AC_ff_hel_imx
real AC_ff_hel_imy
real AC_ff_hel_imz
//  Additional helper params  //  (deduced from other params do not set these directly!)
real AC_G_const
real AC_GM_star
real AC_unit_mass
real AC_sq2GM_star
real AC_cs2_sound
//
real AC_current_time

output real timestep_out;
output real timestep_out1;
output real timestep_out2;




const Field3 UU  = Field3(VTXBUF_UUX,VTXBUF_UUY,VTXBUF_UUZ)

#if LMAGNETIC
const Field3 AA  = Field3(VTXBUF_AX,VTXBUF_AY,VTXBUF_AZ)
#endif


#if LSHOCK
#include "smooth_kernel.ach" 
#endif 
#if LMAGNETIC
induction() {
    return cross(UU, curl(AA)) + AC_eta * laplace(AA)
}
#endif







#if LFORCING
// The Pencil Code forcing_hel_noshear(), manual Eq. 222, inspired forcing function with adjustable
// helicity
helical_forcing(k_force, xx, ff_re, ff_im, phi)
{
    real3 yy
    yy.x = xx.x * (2.0 * R_PI / (AC_dsx * AC_nxgrid))
    yy.y = xx.y * (2.0 * R_PI / (AC_dsy * AC_nygrid))
    yy.z = xx.z * (2.0 * R_PI / (AC_dsz * AC_nzgrid))

    cos_phi     = cos(phi)
    sin_phi     = sin(phi)
    cos_k_dot_x = cos(dot(k_force, yy))
    sin_k_dot_x = sin(dot(k_force, yy))
    real_comp_phase = cos_k_dot_x * cos_phi - sin_k_dot_x * sin_phi
    imag_comp_phase = cos_k_dot_x * sin_phi + sin_k_dot_x * cos_phi

    force = real3(ff_re.x * real_comp_phase - ff_im.x * imag_comp_phase,
                  ff_re.y * real_comp_phase - ff_im.y * imag_comp_phase,
                  ff_re.z * real_comp_phase - ff_im.z * imag_comp_phase)

    return force
}

forcing(dt)
{
    xx = real3((globalVertexIdx.x - AC_nx_min) * AC_dsx,
               (globalVertexIdx.y - AC_ny_min) * AC_dsy,
               (globalVertexIdx.z - AC_nz_min) * AC_dsz)
    cs  = sqrt(AC_cs2_sound)

    // Placeholders until determined properly
    k_force   = real3(AC_k_forcex,   AC_k_forcey,   AC_k_forcez  )
    ff_re     = real3(AC_ff_hel_rex, AC_ff_hel_rey, AC_ff_hel_rez)
    ff_im     = real3(AC_ff_hel_imx, AC_ff_hel_imy, AC_ff_hel_imz)

    // Determine that forcing funtion type at this point.
    force = helical_forcing(k_force, xx, ff_re, ff_im, AC_forcing_phase)

    // Scaling N = magnitude*cs*sqrt(k*cs/dt)  * dt
    NN = cs * AC_forcing_magnitude * sqrt(AC_kaver * cs)
    // sqrt(dt) because 1/sqrt(dt)*dt = sqrt(dt)
    force.x = sqrt(dt) * NN * force.x
    force.y = sqrt(dt) * NN * force.y
    force.z = sqrt(dt) * NN * force.z

    return force
}
#endif // LFORCING


continuity() {
    return -dot(UU, gradient(VTXBUF_LNRHO)) - divergence(UU)
#if LUPWD
           + dot(abs(UU), gradient_upwd(VTXBUF_LNRHO))
#endif

}

momentum() {
    S = traceless_rateof_strain(UU)
    cs2_sound = AC_cs_sound * AC_cs_sound
#if LENTROPY 
    cs2 = cs2_sound * exp(AC_gamma * VTXBUF_ENTROPY / AC_cp_sound + (AC_gamma - 1.) * (VTXBUF_LNRHO - AC_lnrho0))
#else
    cs2 = cs2_sound
#endif
#if LMAGNETIC
    j = (1. / AC_mu0) * (gradient_of_divergence(AA) - laplace(AA))
    B = curl(AA)
    inv_rho = 1. / exp(VTXBUF_LNRHO)
#endif

    mom = - gradient(UU) * UU
#if LUPWD
          + gradient_upwd(UU) * abs(UU)
#endif
#if LENTROPY 
          - cs2 * ((1. / AC_cp_sound) * gradient(VTXBUF_ENTROPY) + gradient(VTXBUF_LNRHO))
#else
          - cs2 * gradient(VTXBUF_LNRHO)
#endif
#if LMAGNETIC
          + inv_rho * cross(j, B)
#endif
          + AC_nu_visc * (laplace(UU) + (1. / 3.) * gradient_of_divergence(UU)
                       + 2. * S * gradient(VTXBUF_LNRHO))
          + AC_zeta * gradient_of_divergence(UU)
#if LSHOCK
          + AC_nu_shock * (VTXBUF_SHOCK * (divergence(UU) * gradient(VTXBUF_LNRHO) +
                                           gradient_of_divergence(UU)) +
                           divergence(UU) * gradient(VTXBUF_SHOCK))
#endif

    return mom
}

#if LENTROPY 
lnT() {
    return AC_lnT0
         + AC_gamma * VTXBUF_ENTROPY / AC_cp_sound
         + (AC_gamma - 1.) * (VTXBUF_LNRHO - AC_lnrho0)
}

heat_conduction() {
    inv_AC_cp_sound = 1. / AC_cp_sound
    grad_ln_chi = -gradient(VTXBUF_LNRHO)

    first_term = AC_gamma * inv_AC_cp_sound * laplace(VTXBUF_ENTROPY) + (AC_gamma - 1.) * laplace(VTXBUF_LNRHO)
    second_term = AC_gamma * inv_AC_cp_sound * gradient(VTXBUF_ENTROPY) + (AC_gamma - 1.) * gradient(VTXBUF_LNRHO)
    third_term = AC_gamma * (inv_AC_cp_sound * gradient(VTXBUF_ENTROPY) + gradient(VTXBUF_LNRHO)) + grad_ln_chi

    //chi = AC_THERMAL_CONDUCTIVITY / (exp(VTXBUF_LNRHO) * AC_cp_sound)
    chi = AC_K_heatcond / (exp(VTXBUF_LNRHO) * AC_cp_sound)

    return AC_cp_sound * chi * (first_term + dot(second_term, third_term))
}

entropy() {
    S = traceless_rateof_strain(UU)
    inv_pT = 1. / (exp(VTXBUF_LNRHO) * exp(lnT()))
#if LMAGNETIC
    j = (1. / AC_mu0) * (gradient_of_divergence(AA) - laplace(AA))
#else
    j = real3(0,0,0)
#endif
#if LSHOCK
    entshock = AC_nu_shock * VTXBUF_SHOCK * (divergence(UU) * divergence(UU))  
#else
    entshock = 0.0
#endif
    RHS = (0) - (0) + AC_eta * AC_mu0 * dot(j, j) +
                       2. * exp(VTXBUF_LNRHO) * AC_nu_visc * contract(S) +
                       entshock +
                       AC_zeta * exp(VTXBUF_LNRHO) * divergence(UU) * divergence(UU)

    return -dot(UU, gradient(VTXBUF_ENTROPY)) + inv_pT * RHS + heat_conduction()
}
#endif

#if LSHOCK
// Get divergence of velocity for the first pass in shock viscosity.
divu_shock()
{
    // Set discard the values which do not contain negative divergence.
    divu = divergence(UU)
    if divu < 0.0 {
        return -divu
    }
    else {
        return 0.0
    }
}

// Calculate local maximum from divergences.
max5_shock()
{
    return max5(VTXBUF_SHOCK)
}

Kernel shock_1_divu()
{
    write(VTXBUF_SHOCK, divu_shock())
}

Kernel shock_2_max()
{
    write(VTXBUF_SHOCK, max5_shock())
}

Kernel shock_3_smooth()
{
    dsmin = AC_dsx //Here assuming that all spacing are equal
    cshock = 1.0  

    s_shock = smooth_kernel(VTXBUF_SHOCK)
    out_shock = cshock*dsmin*dsmin*s_shock //Add scaling constant cshock

    write(VTXBUF_SHOCK, out_shock)
}

#endif
#
/**
Kernel test_func()
{
   if(AC_runtime_int) 
   {
	write(DEAD_FIELD,AC_real_gmem_arr[0])
   }
}
**/




reduce_test(step_num)
{
    reduce_sum(step_num == 0, 2.0, timestep_out)
}

bool bool_param


Kernel singlepass_solve(int step_num, TimeParams time_params, EnumParams enums) {
	if bool_param
	{
		print("HI\n")
	}
    if enums.heatcond == NOTHING 
    {
	print("HI\n")
    }
    else if enums.heatcond == K_const
    {
	print("Kobra\n")
    }
	if bool_param
	{
		print("BYE\n")
	}
	
    write(VTXBUF_LNRHO, rk3(VTXBUF_LNRHO, continuity(), step_num, time_params.dt))

#if LENTROPY 
    write(VTXBUF_ENTROPY, rk3(VTXBUF_ENTROPY, entropy(),step_num, time_params.dt))
#endif 
#if LFORCING
    //Add the forcing component to the velocity field at the last integration step.
    //Important to init to zero here: ohterwise will produce numerical garbage! 
    forcing_step = real3(0.0, 0.0, 0.0)
    if step_num == 2 {
        if time_params.current_time > AC_switch_forcing {
            forcing_step = forcing(time_params.dt)
        }
    }
    write(UU, rk3(UU, momentum(), step_num,time_params.dt) + forcing_step)
#else 
    write(UU, rk3(UU, momentum(), step_num,time_params.dt))
#endif

#if LMAGNETIC
    write(AA, rk3(AA, induction(), step_num, time_params.dt))
#endif

#if LBFIELD
        write(BFIELD, curl(AA))	
#endif

#if LSHOCK
    // Required for buffers to match correctly. 
    write(VTXBUF_SHOCK, VTXBUF_SHOCK)
#endif
    reduce_min(step_num == 0, 2.0, timestep_out1)
    reduce_test(step_num)
    reduce_max(step_num == 0, 2.0, timestep_out2)
}


Kernel twopass_solve_intermediate(int step_num, real dt) {

	real3 var = real3(0.0,0.0,0.0)
	var = 0.0
	real4 var4 = (real4){0.0,0.0,0.0,0.0}
	var4 = 0.0
    write(VTXBUF_LNRHO, rk3_intermediate(VTXBUF_LNRHO, continuity(), step_num, dt))

    #if LENTROPY 
    write(VTXBUF_ENTROPY, rk3_intermediate(VTXBUF_ENTROPY, entropy(), step_num, dt))
    #endif

    write(UU, rk3_intermediate(UU, momentum(), step_num, dt))

    #if LMAGNETIC
    write(AA, rk3_intermediate(AA, induction(), step_num, dt))
    #endif

    #if LBFIELD
    //if step_num == 2 {
	write(BFIELD,curl(AA))
    ////}
    #endif

    // %JP: TODO NOTE IMPORTANT (MV please check)
    // LSHOCK not yet adapted to two-pass integration.
    // Unclear how should be written to memory to ensure proper swapping!
    // 1) In the single-pass approach need to write the shock field to `out`
    // because buffers are swapped afterwards
    // 2) In the two-pass approach this may not be necessary: if the shock
    // field is in `in` buffer and we swap twice, the correct shock values are
    // still in the `in` buffer
    //
    // Is this correct?
    //
}

Kernel twopass_solve_final(int step_num, real current_time) {
    write(VTXBUF_LNRHO, rk3_final(VTXBUF_LNRHO, step_num))

    #if LENTROPY 
    write(VTXBUF_ENTROPY, rk3_final(VTXBUF_ENTROPY, step_num))
    #endif

    forcing_step = real3(0.0, 0.0, 0.0)
    #if LFORCING
    if step_num == 2 {
        if current_time > AC_switch_forcing {
            forcing_step = forcing()
        }
    }
    #endif
    write(UU, rk3_final(UU, step_num) + forcing_step)

    #if LMAGNETIC
    write(AA, rk3_final(AA, step_num))
    #endif
}

// Scale all fields by a scaling factor
// TODO ensure AC_scaling_factor is set!
real AC_scaling_factor
utility Kernel scale() {
    for field in 0:NUM_FIELDS
        write(Field(field), Field(field))

#if LMAGNETIC
    write(AA, AC_scaling_factor*AA)
#else
    if vertexIdx.x == AC_mx/2 && vertexIdx.y == AC_my/2 && vertexIdx.z == AC_mz/2 {
        print("WARNING: scale kernel called but LMAGNETIC was not enabled. Scale will have no effect.")
    }
#endif
}

utility Kernel reset() {
    for field in 0:NUM_FIELDS {
       write(Field(field), 0.0)
    }
}

/*
xorshift(state) {
    x = 1 + uint64_t(state)
    x ^= x << 12
    x ^= x >> 25
    x ^= x << 27
    return x * 0x2545F4914F6CDD1D
}

utility Kernel randomize() {
    // N.B. scale: result in [-AC_rng_scale, AC_rng_scale] range
    AC_rng_scale = 1e-5

    for field in 0:NUM_FIELDS {
        i = uint64_t(globalVertexIdx.x) + uint64_t(globalVertexIdx.y) * uint64_t(AC_nxgrid) + uint64_t(globalVertexIdx.z) * uint64_t(AC_nxgrid) * uint64_t(AC_nygrid) + uint64_t(field) * uint64_t(AC_nxgrid) * uint64_t(AC_nygrid) * uint64_t(AC_nzgrid)
        //i += i*i + i*i*i + i*i*i*i + i*i*i*i*i // Add some non-linearity
        
        // Generate some entropy
        for step in 0:10 {
            i = xorshift(i)
        }
        for step in 0:(i % 40) {
            i = xorshift(i)
        }

        // Simple linear congruential RNG
        //write(Field(field), 2.0 * ((75 * i + 74 + 3257*i*i + 6067*i*i*i + 7919*i*i*i*i)%999331) / 999331 - 1.0)
        
        // xorshift*
        //seed = uint64_t(AC_nxgrid) * uint64_t(AC_nygrid) * uint64_t(AC_nzgrid) * uint64_t(NUM_FIELDS)
        r = 2.0 * xorshift(i) / UINT64_MAX - 1.0
        write(Field(field), AC_rng_scale * r)
    }
    real r = 2.0 * xorshift(0) / UINT64_MAX - 1.0
}
*/

utility Kernel randomize() {
    
    // N.B. scale: result in (-AC_rng_scale, AC_rng_scale] range
    AC_rng_scale = 1e-5

    for field in 1:NUM_FIELDS {
        r = 2.0 * rand_uniform() - 1.0
        write(Field(field), AC_rng_scale * r)
    }
}



Kernel haatouken() {
    // Parameters
    // Shock punch the air in front of you.
    // AC_init_ampl_uu
    // AC_init_shell_radius
    // AC_init_shell_width

    xx = grid_position()  -  grid_centre()

    rr = norm(xx) 

    theta = atan2(xx.z, xx.x)
    phi   = atan2(xx.y, xx.x)

    uu_radial = 0.0

    if rr > 2.0*AC_dsx { 
        uu_radial = AC_init_ampl_uu * 
                    exp(-pow((rr - AC_init_shell_radius), 2.0) / (2.0 * pow(AC_init_shell_width, 2.0))) *
                    exp(-pow(theta , 2.0) / (2.0 * pow(R_PI / 8.0, 2.0))) *
                    exp(-pow(phi, 2.0) / (2.0 * pow(R_PI / 8.0, 2.0)))
    } 

    //if (rr > 0.8 && rr < 1.2) {
    //    if (phi < R_PI/8.0 && phi > -R_PI/8.0) {
    //        if (theta < R_PI/8 && theta > -R_PI/8) {
    //            uu_radial = AC_init_ampl_uu 
    //        }
    //    }
    //} 

    
    uu_addition = 
    uu_radial * (real3){
	cos(theta) * cos(phi),
	cos(theta) * sin(phi),
	cos(theta)
    }

    write(UU, UU + uu_addition)
}

get_d_from_normal(normal)
{
    return 
    	normal.x != 0.0 ? AC_dsx :
	normal.y != 0.0 ? AC_dsy :
	AC_dsz
}
get_uudir(boundary_in, int3 normal_in, VtxBuffer vtxbuf)
{
    real uudir_out = (normal_in.x != 0) ? vtxbuf[boundary_in.x][boundary_in.y][boundary_in.z]*normal_in.x :
		     (normal_in.y != 0) ? vtxbuf[boundary_in.x][boundary_in.y][boundary_in.z]*normal_in.y :
		     vtxbuf[boundary_in.x][boundary_in.y][boundary_in.z]*normal_in.z
    return uudir_out
}

get_boundary_from_normal(normal_in)
{
    return 
    (int3)
    {
    	(normal_in.x ==  1) ? NGHOST_VAL + AC_nx - 1 :
	(normal_in.x == -1) ? NGHOST_VAL :
	vertexIdx.x,

    	normal_in.y ==  1 ? NGHOST_VAL + AC_ny - 1 :
    	normal_in.y == -1 ? NGHOST_VAL :
    	vertexIdx.y,

    	normal_in.z ==  1 ? NGHOST_VAL + AC_nz - 1 :
    	normal_in.z == -1 ? NGHOST_VAL :
    	vertexIdx.z;
    }	
}
prescribed_derivative_boundcond(int3 normal, VtxBuffer vtxbuf, real der_val)
{
    d = get_d_from_normal(normal)
    real direction = (normal.x != 0) ? normal.x :
		     (normal.y != 0) ? normal.y : 
		     normal.z;
    int3 boundary = get_boundary_from_normal(normal)
    int3 ghost  = boundary
    int3 domain = boundary
    for  i  in 0:NGHOST_VAL {
        domain = domain - normal
        ghost  = ghost + normal
	distance = 2 * (i + 1)*d
	//distance = direction < 0.0 ? -distance : distance
	if direction < 0.0
		distance = -distance
	distance = 2 ? 1 : 0
	vtxbuf[ghost.x][ghost.y][ghost.z] = vtxbuf[domain.x][domain.y][domain.z] + distance*der_val
    }
}


beltrami(real ampl, ex, ey, ez, kx, ky, kz, phase) {
    // Based on Pencil Code beltrami_general() 
    // https://github.com/pencil-code/pencil-code/blob/43f0b658a905bbeb641daa0ccf88720a20f0c562/src/initcond.f90#L1818C16-L1818C32

    kxe_x = ky*ez - kz*ey
    kxe_y = kz*ex - kx*ez
    kxe_z = kx*ey - ky*ex

    kxkxe_x = ky*kxe_z - kz*kxe_y
    kxkxe_y = kz*kxe_x - kx*kxe_z
    kxkxe_z = kx*kxe_y - ky*kxe_x

    kk=sqrt(kx*kx+ky*ky+kz*kz)

    xx = grid_position()

    cfunc = abs(ampl) * cos(kx*xx.x + ky*xx.y + kz*xx.z + phase)
    sfunc =     ampl  * sin(kx*xx.x + ky*xx.y + kz*xx.z + phase)

    field = real3(kxkxe_x*cfunc + kk*kxe_x*sfunc,   
                  kxkxe_y*cfunc + kk*kxe_y*sfunc,   
                  kxkxe_z*cfunc + kk*kxe_z*sfunc)

    return field
}

Kernel beltrami_initcond() {
    //uu = beltrami(1e-5, 0.0, 0.0, 1.0, 3.0, 2.0, 3.0, 0.0)
    aa = beltrami(1e-5, 0.0, 0.0, 1.0, 6.0, 4.0, 6.0, 0.0)

    //write(UU, uu)
    write(AA, aa)
}

radial_vector_field(ampl) {
    xx = grid_position() - grid_centre()
    rr = sqrt(xx.x*xx.x + xx.y*xx.y + xx.z*xx.z)
    rr_xy = sqrt(xx.x*xx.x + xx.y*xx.y )
    field = real3(0.0,
                  0.0,
                  0.0)

    if (rr >= 2.0*AC_dsx){

        theta = real(atan2(rr_xy, xx.z))

        phi   = real(atan2(xx.y, xx.x))

        field = real3(ampl * cos(theta)* cos(phi),  
                      ampl * cos(theta)* sin(phi),  
                      ampl * cos(theta))
    }

    return field
}

Kernel radial_vec_initcond() {
    write(UU, radial_vector_field(-1e-5))
}

utility Kernel constant() {
    
    AC_value = 1.0

    for field in 0:NUM_FIELDS {
        write(Field(field), AC_value)
    }
}
real AC_density_scale_cgs
real AC_impossible
real AC_unit_length
real AC_density_scale_factor
int AC_ldensity_nolog



gmem real AC_z[AC_nz]
const bool ldensity_nolog = false
const int n1 = NGHOST_VAL + 1
int n2


bc_steady_z(topbot,VtxBuffer j)
{
  int i;
  if(topbot == AC_bot) {
    if (j[vertexIdx.x][vertexIdx.y][n1-1] <= 0.0) {
      for i in 1:NGHOST_VAL+1 {
        j[vertexIdx.x][vertexIdx.y][n1-i-1]=j[vertexIdx.x][vertexIdx.y][n1-1];
      }
    }
    else {
      if (j[vertexIdx.x][vertexIdx.y][n1-1] > j[vertexIdx.x][vertexIdx.y][n1+1-1]) {
        j[vertexIdx.x][vertexIdx.y][n1-1-1]=0.5*(j[vertexIdx.x][vertexIdx.y][n1-1]    +j[vertexIdx.x][vertexIdx.y][1+n1-1]);
      }
      else {
        j[vertexIdx.x][vertexIdx.y][n1-1-1]=2.0* j[vertexIdx.x][vertexIdx.y][n1-1]    -j[vertexIdx.x][vertexIdx.y][1+n1-1];
      }
      for i in 2:NGHOST_VAL+1 {
        j[vertexIdx.x][vertexIdx.y][n1-i-1]=2.0* j[vertexIdx.x][vertexIdx.y][n1-i+1-1]-j[vertexIdx.x][vertexIdx.y][n1-i+2-1];
      }
    }
  }
  else if(topbot == AC_top) {
    if (j[vertexIdx.x][vertexIdx.y][n2-1] >= 0.0) {
      for i in 1:NGHOST_VAL+1 {
        j[vertexIdx.x][vertexIdx.y][n2+i-1]=j[vertexIdx.x][vertexIdx.y][n2-1];
      }
    }
    else {
      if (j[vertexIdx.x][vertexIdx.y][n2-1] < j[vertexIdx.x][vertexIdx.y][n2-1-1]) {
        j[vertexIdx.x][vertexIdx.y][1+n2-1]=0.5*(j[vertexIdx.x][vertexIdx.y][n2-1]    +j[vertexIdx.x][vertexIdx.y][n2-1-1]);
      }
      else {
        j[vertexIdx.x][vertexIdx.y][1+n2-1]=2.0* j[vertexIdx.x][vertexIdx.y][n2-1]    -j[vertexIdx.x][vertexIdx.y][n2-1-1];
      }
      for i in 2:NGHOST_VAL+1 {
        j[vertexIdx.x][vertexIdx.y][n2+i-1]=2.0* j[vertexIdx.x][vertexIdx.y][n2+i-1-1]-j[vertexIdx.x][vertexIdx.y][n2+i-2-1];
      }
    }
  }
  else {
  }
}
real fbotkbot
real ftopktop
real fbot
real ftop
real nkramers
real hcond0_kramers
int lheatc_chiconst
int lheatc_kramers
int AC_pretend_lntt

real AC_cs20
real AC_gamma_m1
real AC_cv1
real AC_dz2_bound[7]
/**
bc_ss_flux(topbot)
{
  real tmp_xy;
  real cs2_xy;
  real rho_xy;
  int i;
  if(topbot == AC_bot) {
    if (AC_pretend_lntt) {
      tmp_xy=-fbotkbot/exp(AC_iss[vertexIdx.x][vertexIdx.y][AC_n1-1]);
      for i in 1:NGHOST_VAL+1 {
        AC_iss[vertexIdx.x][vertexIdx.y][AC_n1-i-1]=AC_iss[vertexIdx.x][vertexIdx.y][AC_n1+i-1]-AC_dz2_bound[-i+NGHOST_VAL]*tmp_xy;
      }
    }
    else {
      if (AC_ldensity_nolog) {
          rho_xy=AC_ilnrho[vertexIdx.x][vertexIdx.y][AC_n1-1];
      }
      else {
        rho_xy=exp(AC_ilnrho[vertexIdx.x][vertexIdx.y][AC_n1-1]);
      }
      cs2_xy = AC_iss[vertexIdx.x][vertexIdx.y][AC_n1-1];
      if (AC_ldensity_nolog) {
        cs2_xy=AC_cs20*exp(AC_gamma_m1*(log(rho_xy)-AC_lnrho0)+AC_cv1*cs2_xy);
      }
      else {
        cs2_xy=AC_cs20*exp(AC_gamma_m1*(AC_ilnrho[vertexIdx.x][vertexIdx.y][AC_n1-1]-AC_lnrho0)+AC_cv1*cs2_xy);
      }
      if (lheatc_chiconst) {
        tmp_xy=fbot/(rho_xy*AC_chi*cs2_xy);
      }
      else if (lheatc_kramers) {
        tmp_xy=fbot*pow(rho_xy,(2*nkramers))*pow((AC_cp*AC_gamma_m1),(6.5*nkramers))  /(hcond0_kramers*pow(cs2_xy,(6.5*nkramers+1.)));
      }
      else {
        tmp_xy=fbotkbot/cs2_xy;
      }
      for i in 1:NGHOST_VAL+1 {
        rho_xy = AC_ilnrho[vertexIdx.x][vertexIdx.y][AC_n1+i-1]-AC_ilnrho[vertexIdx.x][vertexIdx.y][AC_n1-i-1];
        if (AC_ldensity_nolog) {
            rho_xy = rho_xy/AC_ilnrho[vertexIdx.x][vertexIdx.y][AC_n1-1];
        }
        AC_iss[vertexIdx.x][vertexIdx.y][AC_n1-i-1]=AC_iss[vertexIdx.x][vertexIdx.y][AC_n1+i-1]+AC_cp*(AC_cp-AC_cv)*(rho_xy+AC_dz2_bound[-i+NGHOST_VAL]*tmp_xy);
      }
    }
  }
  else if(topbot == AC_top) {
    if (AC_pretend_lntt) {
      tmp_xy=-ftopktop/exp(AC_iss[vertexIdx.x][vertexIdx.y][AC_n2-1]);
      for i in 1:NGHOST_VAL+1 {
        AC_iss[vertexIdx.x][vertexIdx.y][AC_n2-i-1]=AC_iss[vertexIdx.x][vertexIdx.y][AC_n2+i-1]-AC_dz2_bound[i+NGHOST_VAL]*tmp_xy;
      }
    }
    else {
      if (AC_ldensity_nolog) {
          rho_xy=AC_ilnrho[vertexIdx.x][vertexIdx.y][AC_n2-1];
      }
      else {
        rho_xy=exp(AC_ilnrho[vertexIdx.x][vertexIdx.y][AC_n2-1]);
      }
      cs2_xy = AC_iss[vertexIdx.x][vertexIdx.y][AC_n2-1];
      if (AC_ldensity_nolog) {
        cs2_xy=AC_cs20*exp(AC_gamma_m1*(log(rho_xy)-AC_lnrho0)+AC_cv1*cs2_xy);
      }
      else {
        cs2_xy=AC_cs20*exp(AC_gamma_m1*(AC_ilnrho[vertexIdx.x][vertexIdx.y][AC_n2-1]-AC_lnrho0)+AC_cv1*cs2_xy);
      }
      if (lheatc_chiconst) {
        tmp_xy=ftop/(rho_xy*AC_chi*cs2_xy);
      }
      else if (lheatc_kramers) {
        tmp_xy=ftop*pow(rho_xy,(2*nkramers))*pow((AC_cp*AC_gamma_m1),(6.5*nkramers))  /(hcond0_kramers*pow(cs2_xy,(6.5*nkramers+1.)));
      }
      else {
        tmp_xy=ftopktop/cs2_xy;
      }
      for i in 1:NGHOST_VAL+1 {
        rho_xy = AC_ilnrho[vertexIdx.x][vertexIdx.y][AC_n2+i-1]-AC_ilnrho[vertexIdx.x][vertexIdx.y][AC_n2-i-1];
        if (AC_ldensity_nolog) {
            rho_xy = rho_xy/AC_ilnrho[vertexIdx.x][vertexIdx.y][AC_n2-1];
        }
        AC_iss[vertexIdx.x][vertexIdx.y][AC_n2+i-1]=AC_iss[vertexIdx.x][vertexIdx.y][AC_n2-i-1]+AC_cp*(AC_cp-AC_cv)*(-rho_xy-AC_dz2_bound[i+NGHOST_VAL]*tmp_xy);
      }
    }
  }
  else {
  }
}
**/

int AC_n2
int AC_n1

int AC_l2
int AC_l1

int AC_m2
int AC_m1


bc_sym_x(sgn,topbot,VtxBuffer j,rel)
{
  int i;
  if(topbot == AC_bot) {
    if (rel) {
      for i in 1:NGHOST_VAL+1 {
        j[AC_l1-i-1][vertexIdx.y][vertexIdx.z]=2*j[AC_l1-1][vertexIdx.y][vertexIdx.z]+sgn*j[AC_l1+i-1][vertexIdx.y][vertexIdx.z];
      }
    }
    else {
      for i in 1:NGHOST_VAL+1 {
        j[AC_l1-i-1][vertexIdx.y][vertexIdx.z]=              sgn*j[AC_l1+i-1][vertexIdx.y][vertexIdx.z];
      }
      if (sgn<0) {
        j[AC_l1-1][vertexIdx.y][vertexIdx.z] = 0.;
      }
    }
  }
  else if(topbot == AC_top) {
    if (rel) {
      for i in 1:NGHOST_VAL+1 {
        j[AC_l2+i-1][vertexIdx.y][vertexIdx.z]=2*j[AC_l2-1][vertexIdx.y][vertexIdx.z]+sgn*j[AC_l2-i-1][vertexIdx.y][vertexIdx.z];
      }
    }
    else {
      for i in 1:NGHOST_VAL+1 {
        j[AC_l2+i-1][vertexIdx.y][vertexIdx.z]=              sgn*j[AC_l2-i-1][vertexIdx.y][vertexIdx.z];
      }
      if (sgn<0) {
        j[AC_l2-1][vertexIdx.y][vertexIdx.z] = 0.;
      }
    }
  }
  else {
  }
}

bc_sym_y(sgn,topbot,VtxBuffer j,rel)
{
  int i;
  if(topbot == AC_bot) {
    if (rel) {
      for i in 1:NGHOST_VAL+1 {
        j[vertexIdx.x][AC_m1-i-1][vertexIdx.z]=2*j[vertexIdx.x][AC_m1-1][vertexIdx.z]+sgn*j[vertexIdx.x][AC_m1+i-1][vertexIdx.z];
      }
    }
    else {
      for i in 1:NGHOST_VAL+1 {
        j[vertexIdx.x][AC_m1-i-1][vertexIdx.z]=              sgn*j[vertexIdx.x][AC_m1+i-1][vertexIdx.z];
      }
      if (sgn<0) {
        j[vertexIdx.x][AC_m1-1][vertexIdx.z] = 0.;
      }
    }
  }
  else if(topbot == AC_top) {
    if (rel) {
      for i in 1:NGHOST_VAL+1 {
        j[vertexIdx.x][AC_m2+i-1][vertexIdx.z]=2*j[vertexIdx.x][AC_m2-1][vertexIdx.z]+sgn*j[vertexIdx.x][AC_m2-i-1][vertexIdx.z];
      }
    }
    else {
      for i in 1:NGHOST_VAL+1 {
        j[vertexIdx.x][AC_m2+i-1][vertexIdx.z]=              sgn*j[vertexIdx.x][AC_m2-i-1][vertexIdx.z];
      }
      if (sgn<0) {
        j[vertexIdx.x][AC_m2-1][vertexIdx.z] = 0.;
      }
    }
  }
  else {
  }
}

const VtxBuffer AC_iss    = VTXBUF_ENTROPY
const VtxBuffer AC_ilnrho = VTXBUF_LNRHO
const VtxBuffer AC_irho = VTXBUF_LNRHO

bc_ism(topbot,VtxBuffer j)
{
  int k;
  real density_scale1;
  real density_scale;
  if (AC_density_scale_factor==AC_impossible) {
    density_scale=AC_density_scale_cgs/AC_unit_length;
  }
  else {
    density_scale=AC_density_scale_factor;
  }
  density_scale1=1./density_scale;
  if(topbot == AC_bot) {
    for k in 1:NGHOST_VAL+1 {
      if (j==AC_irho  ||  j==AC_ilnrho) {
        if (AC_ldensity_nolog) {
          j[vertexIdx.x][vertexIdx.y][k-1]=j[vertexIdx.x][vertexIdx.y][AC_n1-1]*exp(-(AC_z[AC_n1]-AC_z[k])*density_scale1);
        }
        else {
          j[vertexIdx.x][vertexIdx.y][k-1]=j[vertexIdx.x][vertexIdx.y][AC_n1-1] - (AC_z[AC_n1]-AC_z[k])*density_scale1;
        }
      }
      else if (j==AC_iss) {
        if (AC_ldensity_nolog) {
          j[vertexIdx.x][vertexIdx.y][AC_n1-k-1]=j[vertexIdx.x][vertexIdx.y][AC_n1-1]+(AC_cp-AC_cv)*(log(AC_irho[vertexIdx.x][vertexIdx.y][AC_n1-1])-log(AC_irho[vertexIdx.x][vertexIdx.y][AC_n1-k-1])) +  AC_cv*log((AC_z[AC_n1]-AC_z[AC_n1-k])*density_scale+1.);
        }
        else {
          j[vertexIdx.x][vertexIdx.y][AC_n1-k-1]=j[vertexIdx.x][vertexIdx.y][AC_n1-1]+(AC_cp-AC_cv)*(AC_ilnrho[vertexIdx.x][vertexIdx.y][AC_n1-1]-AC_ilnrho[vertexIdx.x][vertexIdx.y][AC_n1-k-1])+  AC_cv*log((AC_z[AC_n1]-AC_z[AC_n1-k])*density_scale+1.);
        }
      }
      else {
      }
    }
  }
  else if(topbot == AC_top) {
    for k in 1:NGHOST_VAL+1 {
      if (j==AC_irho  ||  j==AC_ilnrho) {
        if (AC_ldensity_nolog) {
          j[vertexIdx.x][vertexIdx.y][AC_n2+k-1]=j[vertexIdx.x][vertexIdx.y][AC_n2-1]*exp(-(AC_z[AC_n2+k]-AC_z[AC_n2])*density_scale1);
        }
        else {
          j[vertexIdx.x][vertexIdx.y][AC_n2+k-1]=j[vertexIdx.x][vertexIdx.y][AC_n2-1] - (AC_z[AC_n2+k]-AC_z[AC_n2])*density_scale1;
        }
      }
      else if (j==AC_iss) {
        if (AC_ldensity_nolog) {
          j[vertexIdx.x][vertexIdx.y][AC_n2+k-1]=j[vertexIdx.x][vertexIdx.y][AC_n2-1]+(AC_cp-AC_cv)*(log(AC_irho[vertexIdx.x][vertexIdx.y][AC_n2-1])-log(AC_irho[vertexIdx.x][vertexIdx.y][AC_n2+k-1]))+  AC_cv*log((AC_z[AC_n2+k]-AC_z[AC_n2])*density_scale+1.);
        }
        else {
          j[vertexIdx.x][vertexIdx.y][AC_n2+k-1]=j[vertexIdx.x][vertexIdx.y][AC_n2-1]+(AC_cp-AC_cv)*(AC_ilnrho[vertexIdx.x][vertexIdx.y][AC_n2-1]-AC_ilnrho[vertexIdx.x][vertexIdx.y][AC_n2+k-1])+  AC_cv*log((AC_z[AC_n2+k]-AC_z[AC_n2])*density_scale+1.);
        }
      }
      else {
      }
    }
  }
  else {
  }
}


bc_sym_z(sgn,topbot,VtxBuffer j,rel)
{
  int i;
  if(topbot == AC_bot) {
    if (rel) {
      for i in 1:NGHOST_VAL+1 {
        j[vertexIdx.x][vertexIdx.y][AC_n1-i-1]=2*j[vertexIdx.x][vertexIdx.y][AC_n1-1]+sgn*j[vertexIdx.x][vertexIdx.y][AC_n1+i-1];
      }
    }
    else {
      for i in 1:NGHOST_VAL+1 {
        j[vertexIdx.x][vertexIdx.y][AC_n1-i-1]=              sgn*j[vertexIdx.x][vertexIdx.y][AC_n1+i-1];
      }
      if (sgn<0) {
        j[vertexIdx.x][vertexIdx.y][AC_n1-1] = 0.;
      }
    }
  }
  else if(topbot == AC_top) {
    if (rel) {
      for i in 1:NGHOST_VAL+1 {
        j[vertexIdx.x][vertexIdx.y][AC_n2+i-1]=j[vertexIdx.x][vertexIdx.y][AC_n2-1]+(j[vertexIdx.x][vertexIdx.y][AC_n2-1]+sgn*j[vertexIdx.x][vertexIdx.y][AC_n2-i-1]);
      }
    }
    else {
      for i in 1:NGHOST_VAL+1 {
        j[vertexIdx.x][vertexIdx.y][AC_n2+i-1]=              sgn*j[vertexIdx.x][vertexIdx.y][AC_n2-i-1];
      }
      if (sgn<0) {
        j[vertexIdx.x][vertexIdx.y][AC_n2-1] = 0.;
      }
    }
  }
  else {
  }
}







//BoundConds boundconds{
//  periodic(BOUNDARY_XY)
//  bc_sym_z(BOUNDARY_Z_TOP, 1.0,AC_top,VTXBUF_UUY,false)
//  bc_sym_z(BOUNDARY_Z_TOP, 1.0,AC_top,VTXBUF_UUZ,false)
//
//  bc_sym_z(BOUNDARY_Z_TOP, 1.0,AC_top,VTXBUF_AX,false)
//  bc_sym_z(BOUNDARY_Z_TOP, 1.0,AC_top,VTXBUF_AY,false)
//  bc_sym_z(BOUNDARY_Z_TOP, 1.0,AC_top,VTXBUF_AZ,false)
//
//  bc_ss_flux(BOUNDARY_Z_TOP, AC_top)
//
//
//  bc_sym_z(BOUNDARY_Z_BOT, 1.0,AC_bot,VTXBUF_UUY,false)
//  bc_sym_z(BOUNDARY_Z_BOT, 1.0,AC_bot,VTXBUF_UUZ,false)
//
//  bc_sym_z(BOUNDARY_Z_BOT, 1.0,AC_bot,VTXBUF_AX,false)
//  bc_sym_z(BOUNDARY_Z_BOT, 1.0,AC_bot,VTXBUF_AY,false)
//  bc_sym_z(BOUNDARY_Z_BOT, 1.0,AC_bot,VTXBUF_AZ,false)
//
//  bc_sym_z(BOUNDARY_Z_BOT, 1.0,AC_bot,VTXBUF_ENTROPY,false)
//
//  bc_steady_z(BOUNDARY_Z_TOP, AC_top,VTXBUF_UUX)
//  bc_steady_z(BOUNDARY_Z_BOT, AC_bot,VTXBUF_UUX)
//
//  bc_ism(BOUNDARY_Z_BOT, AC_bot,VTXBUF_LNRHO)
//  bc_ism(BOUNDARY_Z_TOP, AC_top,VTXBUF_LNRHO)
//
//}

BoundConds boundconds{
  periodic(BOUNDARY_XYZ)
}

input int  AcInputStepNum
input real AcInputdt
input real AcInputCurrentTime


ComputeSteps AC_rhs(boundconds)
{
        twopass_solve_intermediate(AC_ITERATION_NUMBER,AcInputdt)
        twopass_solve_final(AC_ITERATION_NUMBER,AcInputCurrentTime);
}

