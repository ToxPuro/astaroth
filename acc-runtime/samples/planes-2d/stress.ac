#include "../../stdlib/math"
Field PHI
Field ORIGINAL_COORDS_X, ORIGINAL_COORDS_Y
Field UX, UY
Field STRESS11, STRESS12, STRESS21, STRESS22
Field VELOCITY_X, VELOCITY_Y
hostdefine STENCIL_ORDER (2)
hostdefine AC_INTEGRATION_ENABLED
real AC_current_time
real AC_dt
int AC_step_num


Stencil smooth
{
	[0][1] = 0.20,
	[0][-1] = 0.20,
	[0][0] = 0.20,
	[1][0] = 0.20,
	[-1][0] = 0.20
}

const real sim_dt=(0.25*0.5)/8;
const real M=0.1;
const real D=1.0;
const int Lengthscale = 162
const int nsteps=1000;
const real eldt=2*pow(10.0,-12.0);

const Matrix TrStr =
{
        {0.01, 0.00, 0.00},
        {0.00, 0.01, 0.00},
        {0.00, 0.00, 0.01}
}
//Density
const real ro=7800.0;
const real ro1 = 1.0/ro
//Elastic constant
const real Eg=200.0 * 1000000000.0;
//Another elastic constant (Poisson ratio)
const real vg=1.0/3.0;
const real cg_diagonal = (1-vg);
const real cg_off_diagonal= vg;
const real cg_non_main= 0.5*(1-2*vg);
const real matrix_coeff = Eg/((1+vg)*(1-2*vg));
const Matrix cg11 =
matrix_coeff*{
	{1-vg, 0.0, 0.0},
	{0.0,vg, 0.0},
	{0.0, 0.0,vg}
};

const Matrix cg22 =
matrix_coeff*{
	{vg, 0.0, 0.0},
	{0.0,1-vg, 0.0},
	{0.0, 0.0, vg}
};
const Matrix cg33 =
matrix_coeff*{
	{vg, 0.0, 0.0},
	{0.0,vg, 0.0},
	{0.0, 0.0, 1-vg}
};

const Matrix cg12 =
matrix_coeff*{
	{0.0, 0.5*(1-2*vg), 0.0},
	{0.0, 0.0, 0.0},
	{0.0, 0.0, 0.0}
};
const Matrix cg21 =
matrix_coeff*{
	{0.0, 0.0, 0.0},
	{0.5*(1-2*vg), 0.0, 0.0},
	{0.0, 0.0, 0.0}
};
const Matrix cg13 =
matrix_coeff*{
	{0.0, 0.0, 0.5*(1-2*vg)},
	{0.0, 0.0, 0.0},
	{0.0, 0.0, 0.0}
};
const Matrix cg31 =
matrix_coeff*{
	{0.0, 0.0, 0.0},
	{0.0, 0.0, 0.0},
	{0.5*(1-2*vg), 0.0, 0.0}
};

const Matrix cg23 =
matrix_coeff*{
	{0.0, 0.0, 0.0},
	{0.0, 0.0, 0.5*(1-2*vg)},
	{0.0, 0.0, 0.0}
};
const Matrix cg32 =
matrix_coeff*{
	{0.0, 0.0, 0.0},
	{0.0, 0.0, 0.0},
	{0.0, 0.5*(1-2*vg), 0.0}
};

Kernel twopass_solve_intermediate(int step_num, real dt) {
}
Kernel twopass_solve_final(int step_num, real current_time) {
}
get_diffusion_val(real time, real distance_2)
{
	return M/(4*AC_REAL_PI*time*D)*exp(-distance_2/(4*D*time));
}

GetCoordsBase(i,j)
{
	x  = (AC_dsx*(i-((AC_nxgrid+1)/2.0)))
	y  = (AC_dsy*(j-((AC_nygrid+1)/2.0)))
        return (real2){x,y};
}
GetCoords(i,j)
{
	return GetCoordsBase(i,j)
}

Field U
Field SOLUTION
Kernel initial_condition()
{
	real2 coords = GetCoords(globalVertexIdx.x+1-NGHOST_VAL,globalVertexIdx.y+1-NGHOST_VAL)
	write(COORDS_X,coords.x)
	write(COORDS_Y,coords.y)

	write(ORIGINAL_COORDS_X,coords.x)
	write(ORIGINAL_COORDS_Y,coords.y)

	x_center, y_center = GetCoords(AC_nxgrid/2, AC_nygrid/2);
	distance_to_center = sqrt(pow(coords.x-x_center,2.0) + pow(coords.y-y_center,2.0))
	const real initial_phi_size = 0.5*pow(10.0,-7.0)
	const real transitlength = 5*AC_dsx*pow(10.0,-8.0)
	const real magic_coeff = 0.51*AC_dsx*pow(10.0,-8)
	if(distance_to_center < initial_phi_size + transitlength + magic_coeff)
	{
		if(distance_to_center < initial_phi_size + magic_coeff)
			write(PHI,1.0)
		else
		{
			phi_val = 0.5*(1 + cos(distance_to_center- initial_phi_size*AC_REAL_PI/transitlength))
			if(phi_val < pow(10.0,-308)) phi_val = 0.0
			write(PHI,phi_val)
		}
	}
	write(VELOCITY_X,0.0)
	write(VELOCITY_Y,0.0)
}
Kernel calc_displacement()
{
	write(UX, COORDS_X - ORIGINAL_COORDS_X)
	write(UY, COORDS_Y - ORIGINAL_COORDS_Y)
}

Kernel calculate_stresses()
{
	simple_shear_x = get_first_order_derivatives(ORIGINAL_COORDS_X,ORIGINAL_COORDS_Y, UX)
	simple_shear_y = get_first_order_derivatives(ORIGINAL_COORDS_X,ORIGINAL_COORDS_Y, UY)

	//TP: calc strains
	real strainxx = simple_shear_x.x-PHI*TrStr[0][0]
	real strainxy = 0.5*(simple_shear_x.y+simple_shear_y.x)-PHI*TrStr[0][1]
	real strainyx = 0.5*(simple_shear_y.x+simple_shear_x.y)-PHI*TrStr[1][0]
	real strainyy = simple_shear_y.y-PHI*TrStr[1][1]

	//TP: from strains get stresses
	stress11 = cg11[0][0]*strainxx+cg11[1][1]*strainyy
	stress12 = cg12[0][1]*strainxy
	stress21 = cg21[1][0]*strainyx
	stress22 = cg22[1][1]*strainyy + cg22[0][0]*strainxx

	write(STRESS11,stress11)
	write(STRESS12,stress12)
	write(STRESS21,stress21)
	write(STRESS22,stress22)
}

Kernel calculate_acceleration()
{	
	dxstressxx, dystressxx = get_first_order_derivatives(COORDS_X, COORDS_Y, STRESS11)
	dxstressxy, dystressxy = get_first_order_derivatives(COORDS_X, COORDS_Y, STRESS12)
	dxstressyx, dystressyx = get_first_order_derivatives(COORDS_X, COORDS_Y, STRESS21)
	dxstressyy, dystressyy = get_first_order_derivatives(COORDS_X, COORDS_Y, STRESS22)
	
	const real damping_coeff = pow(10.0,15.0)
	ax = (dxstressxx + dystressxy)/ro - VELOCITY_X*damping_coeff/ro
	ay = (dxstressyx + dystressyy)/ro - VELOCITY_Y*damping_coeff/ro
	write(VELOCITY_X, VELOCITY_X + ax*eldt);
	write(VELOCITY_Y, VELOCITY_Y + ay*eldt);
}
Kernel smooth_velocities_and_update_coordinates()
{
	smoothed_vel_x  = smooth(VELOCITY_X)
	smoothed_vel_y  = smooth(VELOCITY_Y)
	
	write(COORDS_X, COORDS_X + smoothed_vel_x)
	write(COORDS_Y, COORDS_Y + smoothed_vel_y)

	write(VELOCITY_X, smoothed_vel_x)
	write(VELOCITY_Y, smoothed_vel_y)
}

/**
Kernel singlepass_solve()
{	
	const real v0x     = diff_left(COORDS_X)
	const real v1x     = diff_down(COORDS_X)
	const real v2x     = diff_right(COORDS_X)
	const real v3x     = diff_up(COORDS_X)

	const real v0y     = diff_left(COORDS_Y)
	const real v1y     = diff_down(COORDS_Y)
	const real v2y     = diff_right(COORDS_Y)
	const real v3y     = diff_up(COORDS_Y)



	const v0f     =  diff_left(U)
	const v1f     =  diff_down(U)
	const v2f     =  diff_right(U)
	const v3f     =  diff_up(U)

	const p0_coords = (real2){v0x,v0y}
        const p1_coords = (real2){v1x,v1y}
        const p2_coords = (real2){v2x,v2y}
        const p3_coords = (real2){v3x,v3y}

	const real A0  = (p0_coords.x*p1_coords.y - p0_coords.y*p1_coords.x);
	const real A1  = (p1_coords.x*p2_coords.y - p1_coords.y*p2_coords.x);
	const real A2  = (p2_coords.x*p3_coords.y - p2_coords.y*p3_coords.x);
	const real A3  = (p3_coords.x*p0_coords.y - p3_coords.y*p0_coords.x);

        const real totalAreaInv = 1.0/(A0 + A1 + A2 + A3);

        const real p0_area_inv = 1.0/(A0 + A3);
        const real p1_area_inv = 1.0/(A1 + A0);
        const real p2_area_inv = 1.0/(A2 + A1);
        const real p3_area_inv = 1.0/(A3 + A2);

	real3 p0 = {v0x,v0y,v0f};
        real3 p1 = {v1x,v1y,v1f};
        real3 p2 = {v2x,v2y,v2f};
        real3 p3 = {v3x,v3y,v3f};


	partials0x,partials0y = PlaneCoeffients_without_inv(p0,p1);
	partials1x,partials1y = PlaneCoeffients_without_inv(p1,p2);
	partials2x,partials2y = PlaneCoeffients_without_inv(p2,p3);
	partials3x,partials3y = PlaneCoeffients_without_inv(p3,p0);

	const real p0x_local = (partials0x + partials1x + partials2x + partials3x)*totalAreaInv;
        const real p0y_local = (partials0y + partials1y + partials2y + partials3y)*totalAreaInv;

        const real p0x = (partials0x + partials3x)*p0_area_inv - p0x_local;
        const real p1x = (partials1x + partials0x)*p1_area_inv - p0x_local;
        const real p2x = (partials2x + partials1x)*p2_area_inv - p0x_local;
        const real p3x = (partials3x + partials2x)*p3_area_inv - p0x_local;

        const real p0y = (partials0y + partials3y)*p0_area_inv - p0y_local;
        const real p1y = (partials1y + partials0y)*p1_area_inv - p0y_local;
        const real p2y = (partials2y + partials1y)*p2_area_inv - p0y_local;
        const real p3y = (partials3y + partials2y)*p3_area_inv - p0y_local;

	p0 = {v0x,v0y,p0x};
        p1 = {v1x,v1y,p1x};
        p2 = {v2x,v2y,p2x};
        p3 = {v3x,v3y,p3x};

	partials0xx = Plane_x_coefficient(p0,p1);
        partials1xx = Plane_x_coefficient(p1,p2);
        partials2xx = Plane_x_coefficient(p2,p3);
        partials3xx = Plane_x_coefficient(p3,p0);


        p0 = {v0x,v0y,p0y};
        p1 = {v1x,v1y,p1y};
        p2 = {v2x,v2y,p2y};
        p3 = {v3x,v3y,p3y};

        partials0yy = Plane_y_coefficient(p0,p1);
        partials1yy = Plane_y_coefficient(p1,p2);
        partials2yy = Plane_y_coefficient(p2,p3);
        partials3yy = Plane_y_coefficient(p3,p0);

	const real Dxx = 2*(partials0xx + partials1xx + partials2xx + partials3xx)*totalAreaInv;
        const real Dyy = 2*(partials0yy + partials1yy + partials2yy + partials3yy)*totalAreaInv;
        update_val = sim_dt*D*(Dxx+Dyy)
	write(U, U + update_val)
}	
**/

