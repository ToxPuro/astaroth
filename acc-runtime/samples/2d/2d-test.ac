const int AC_const_ints = {1,2,3}
const int AC_const_ints_len = 3
const real AC_const_real = 2.0
const int Matrix_size = 2;
enum IHEATCOND
{
	NOTHING,
	K_const,
	SOMETHING
} 

struct TimeParams
{
        real dt;
        real current_time;
}

struct EnumParams
{
	bool test;
	IHEATCOND heatcond;
}  

const real AC_const_reals = {1.0,2,0,3.0}

const bool AC_const_bool = false
const bool AC_const_bool_true = true
const bool AC_const_bool_arr = {true,false}
//const int AC_first = 1, AC_second = 2
const int AC_first = 2
const int AC_second = 2
const bool AC_first_bool = false, AC_second_bool = true
const bool AC_first_bool_arr = {false,false}, AC_third_bool= true

int AC_step_number

/*
real AC_cs_sound, AC_cp_sound
real AC_gamma, AC_nu_visc, AC_zeta, AC_eta
real AC_lnrho0, AC_mu0, AC_lnT0
*/
// Note: not used by mhdsolver.ac at the moment (src/utils/modelsolver.c does)
//hostdefine AC_INTEGRATION_ENABLED // Enables acIntegrate() and other non-generic library functions
hostdefine LDENSITY (1)
hostdefine LHYDRO (1)
hostdefine LMAGNETIC (1)
hostdefine LENTROPY (1)
hostdefine LTEMPERATURE (0)
hostdefine LFORCING (0)
hostdefine LUPWD (1)
hostdefine LSINK (0)
hostdefine LBFIELD (1 && LMAGNETIC) // bfield only relevant if magnetic is on
hostdefine LSHOCK (1)
hostdefine LTEST (0)
//hostdefine AC_THERMAL_CONDUCTIVITY (0.001) // Now a config parameter, AC_K_heatcond, as it should be. 
hostdefine R_PI (AC_REAL_PI)

// Enables a set of special reductions. Currently for primarily for testing
// purposes:  
hostdefine LSPECIAL_REDUCTIONS (0)  




const int AC_const_int = 2
const int AC_const_int_2nd = 4
//const int nghost = 3
//Field CHEMISTRY_FIELDS[5]

Field UU

int AC_save_steps

// snapshot period
int AC_bin_steps
real AC_bin_save_t

// slices output period
int AC_slice_steps
real AC_slice_save_t

// maximun number of time snapshots during runtime 
// Set AC_num_snapshots < 0 for unlimited snapshots
int AC_num_snapshots

// max simulation time
int AC_max_steps
real AC_max_time

// Forcing parameter generation period (if forcing is on)
int AC_forcing_period_steps
real AC_forcing_period_t

// Initial time step index, default should be 0
int AC_start_step

real AC_dsx, AC_dsy, AC_dsz 


// Real params
// Spacing
real AC_dsmin
// physical grid
real AC_xlen
real AC_ylen
real AC_zlen
real AC_xorig
real AC_yorig
real AC_zorig
// Physical units
real AC_unit_density
real AC_unit_velocity
real AC_unit_length
real AC_unit_magnetic
// properties of gravitating star
real AC_star_pos_x
real AC_star_pos_y
real AC_star_pos_z
real AC_M_star
// properties of sink particle
real AC_sink_pos_x
real AC_sink_pos_y
real AC_sink_pos_z
real AC_M_sink
real AC_M_sink_init
real AC_M_sink_Msun
real AC_soft
real AC_accretion_range
real AC_switch_accretion
//  Run params
real AC_cdt
real AC_cdtv
real AC_cdts
real AC_nu_visc
real AC_cs_sound
real AC_eta
real AC_mu0
real AC_cp_sound
real AC_gamma
real AC_cv_sound
real AC_lnT0
real AC_lnrho0
real AC_zeta
real AC_trans
real AC_nu_shock
real AC_K_heatcond

//  Parameters for generic boundary conditions, this is a dummy variable for testing, please use different ones for each field
real AC_boundary_derivative

//  Parameters only used in boundary conditions at the moment
//  If you feel they should be elsewhere, please move them
real AC_hcond0_kramers
real AC_hflux
real AC_n_kramers
real AC_sigma_SBt
real AC_chi
real AC_chi_t
real AC_chi_t_prof1

//  Initial condition params
real AC_ampl_lnrho
real AC_ampl_uu
real AC_init_ampl_uu
real AC_angl_uu
real AC_lnrho_edge
real AC_lnrho_out
real AC_ampl_aa
real AC_init_k_wave
real AC_init_sigma_hel
real AC_init_shell_radius
real AC_init_shell_width
//  Forcing parameters. User configured.
real AC_forcing_magnitude
real AC_relhel
real AC_kmin
real AC_kmax
real AC_switch_forcing
//  Forcing parameters. Set by the generator.
real AC_forcing_phase
real AC_k_forcex
real AC_k_forcey
real AC_k_forcez
real AC_kaver
real AC_ff_hel_rex
real AC_ff_hel_rey
real AC_ff_hel_rez
real AC_ff_hel_imx
real AC_ff_hel_imy
real AC_ff_hel_imz
//  Additional helper params  //  (deduced from other params do not set these directly!)
real AC_G_const
real AC_GM_star
real AC_unit_mass
real AC_sq2GM_star
real AC_cs2_sound
//
real AC_current_time

output real timestep_out;
output real timestep_out1;
output real timestep_out2;
const int test_arr_size = 6;
real AC_test_arr[test_arr_size];
real AC_test_arr_2[(2-1)*2+1];
int AC_test_int_arr[test_arr_size/2];



#include "../../stdlib/derivs.h"

Kernel singlepass_solve(real dt) {
    write(UU, value(UU) + dt*( derxx(UU) + deryy(UU)))
}



Kernel reset() {
    for field in 0:NUM_FIELDS {
        write(Field(field), 0.0)
    }
}

/*
xorshift(state) {
    x = 1 + uint64_t(state)
    x ^= x << 12
    x ^= x >> 25
    x ^= x << 27
    return x * 0x2545F4914F6CDD1D
}

Kernel randomize() {
    // N.B. scale: result in [-AC_rng_scale, AC_rng_scale] range
    AC_rng_scale = 1e-5

    for field in 0:NUM_FIELDS {
        i = uint64_t(globalVertexIdx.x) + uint64_t(globalVertexIdx.y) * uint64_t(AC_nxgrid) + uint64_t(globalVertexIdx.z) * uint64_t(AC_nxgrid) * uint64_t(AC_nygrid) + uint64_t(field) * uint64_t(AC_nxgrid) * uint64_t(AC_nygrid) * uint64_t(AC_nzgrid)
        //i += i*i + i*i*i + i*i*i*i + i*i*i*i*i // Add some non-linearity
        
        // Generate some entropy
        for step in 0:10 {
            i = xorshift(i)
        }
        for step in 0:(i % 40) {
            i = xorshift(i)
        }

        // Simple linear congruential RNG
        //write(Field(field), 2.0 * ((75 * i + 74 + 3257*i*i + 6067*i*i*i + 7919*i*i*i*i)%999331) / 999331 - 1.0)
        
        // xorshift*
        //seed = uint64_t(AC_nxgrid) * uint64_t(AC_nygrid) * uint64_t(AC_nzgrid) * uint64_t(NUM_FIELDS)
        r = 2.0 * xorshift(i) / UINT64_MAX - 1.0
        write(Field(field), AC_rng_scale * r)
    }
}
*/

Kernel randomize() {
    
    // N.B. scale: result in (-AC_rng_scale, AC_rng_scale] range
    AC_rng_scale = 1e-5

    for field in 0:NUM_FIELDS {
        r = 2.0 * rand_uniform() - 1.0
        write(Field(field), AC_rng_scale * r)
    }
}



Kernel constant() {
    
    AC_value = 1.0

    for field in 0:NUM_FIELDS {
        write(Field(field), AC_value)
    }
}


