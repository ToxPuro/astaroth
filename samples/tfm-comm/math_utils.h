#pragma once
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

bool any(const size_t count, const bool* arr);

bool all(const size_t count, const bool* arr);

size_t prod(const size_t count, const size_t* arr);

void cumprod(const size_t count, const size_t* restrict in, size_t* restrict out);

size_t powzu(const size_t base, const size_t exponent);

size_t binomial_coefficient(const size_t n, const size_t k);

size_t count_combinations(const size_t n);

void rshift(const size_t shift, const size_t fill_value, const size_t count, size_t* arr);

size_t dot(const size_t count, const size_t* a, const size_t* b);

void factorize(const size_t n_initial, size_t* nfactors, size_t* factors);

size_t popcount(const size_t count, const size_t* arr);

/** Requires that array is ordered */
size_t unique(const size_t count, size_t* arr);

size_t unique_subsets(const size_t count, const size_t* a, size_t subset_length, size_t* b);

void transpose(const size_t* in, const size_t nrows, const size_t ncols, size_t* out);

void contract(const size_t* in, const size_t length, const size_t factor, size_t* out);

int64_t mod(const int64_t a, const int64_t b);

void mod_pointwise(const size_t count, const int64_t* a, const int64_t* b, int64_t* c);

void to_spatial(const size_t index, const size_t ndims, const size_t* shape, size_t* output);

size_t to_linear(const size_t ndims, const size_t* index, const size_t* shape);

void reverse(const size_t count, size_t* arr);

void reversei(const size_t count, int* arr);

void set(const size_t value, const size_t count, size_t* arr);

void iset(const int value, const size_t count, int* arr);

void add_to_array(const size_t value, const size_t count, size_t* arr);

void add_arrays(const size_t count, const size_t* a, const size_t* b, size_t* c);

void subtract_arrays(const size_t count, const size_t* a, const size_t* b, size_t* c);

/** Calculates the element-wise product (Hadamard product) of two flattened matrices */
void mul(const size_t count, const size_t* a, const size_t* b, size_t* c);

/** Repeats `count` elements in `a` `nrepeats` times and writes the result to b.
 * `b`is required to be able to hold at least `count*nrepeats` elements.
 * E.g. repeat(2, (size_t[]){1,2}, 3, ...) -> {1, 2, 1, 2, 1, 2}
 */
void repeat(const size_t count, const size_t* a, const size_t nrepeats, size_t* b);

void swap(const size_t i, const size_t j, const size_t count, size_t* arr);

void sort(const size_t count, size_t* arr);

bool intersect_lines(const size_t a1, const size_t a2, const size_t b1, const size_t b2);

bool intersect_box(const size_t ndims, const size_t* a_start, const size_t* a_dims,
                   const size_t* b_start, const size_t* b_dims);

bool within_box(const size_t ndims, const size_t* coords, const size_t* box_min,
                const size_t* box_max);

// Autogenerated start
#define min(a, b)                                                                                  \
    _Generic((a),                                                                                  \
        int: min_int,                                                                              \
        int64_t: min_int64_t,                                                                      \
        size_t: min_size_t,                                                                        \
        float: min_float,                                                                          \
        double: min_double)(a, b)

int min_int(const int a, const int b);
int64_t min_int64_t(const int64_t a, const int64_t b);
size_t min_size_t(const size_t a, const size_t b);
float min_float(const float a, const float b);
double min_double(const double a, const double b);
int min_int(const int a, const int b);
int64_t min_int64_t(const int64_t a, const int64_t b);
size_t min_size_t(const size_t a, const size_t b);
float min_float(const float a, const float b);
double min_double(const double a, const double b);
// Autogenerated end

/** Unit testing */
bool equals(const size_t count, const size_t* a, const size_t* b);
bool all_less_than(const size_t count, const size_t* a, const size_t* b);
void test_math_utils(void);
