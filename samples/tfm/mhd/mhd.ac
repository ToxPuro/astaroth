// Defines
hostdefine AC_INTEGRATION_ENABLED (0) // Enables acIntegrate() and other non-generic library functions
hostdefine LDENSITY (1)
hostdefine LHYDRO (1)
hostdefine LMAGNETIC (0)
hostdefine LENTROPY (0)
hostdefine LTEMPERATURE (0)
hostdefine LFORCING (0)
hostdefine LUPWD (1)
hostdefine R_PI (AC_REAL_PI)
hostdefine LTFM (1)

// Fields
Field VTXBUF_LNRHO, VTXBUF_UUX, VTXBUF_UUY, VTXBUF_UUZ
#define UU Field3(VTXBUF_UUX, VTXBUF_UUY, VTXBUF_UUZ)

#if LMAGNETIC
Field VTXBUF_AX, VTXBUF_AY, VTXBUF_AZ
#define AA Field3(VTXBUF_AX, VTXBUF_AY, VTXBUF_AZ)
#endif

#if LENTROPY 
Field VTXBUF_ENTROPY
#endif

#if LTFM
// Aliases for VTXBUF_UU to avoid confusion with the notation convention
// for mean and fluctuating fields
#define FIELD_u_x (VTXBUF_UUX)
#define FIELD_u_y (VTXBUF_UUY)
#define FIELD_u_z (VTXBUF_UUZ)

// Test fields
Field TF_b11_x, TF_b11_y, TF_b11_z
Field TF_b12_x, TF_b12_y, TF_b12_z
Field TF_b21_x, TF_b21_y, TF_b21_z
Field TF_b22_x, TF_b22_y, TF_b22_z

#define TF_b11 Field3(TF_b11_x, TF_b11_y, TF_b11_z)
#define TF_b12 Field3(TF_b12_x, TF_b12_y, TF_b12_z)
#define TF_b21 Field3(TF_b21_x, TF_b21_y, TF_b21_z)
#define TF_b22 Field3(TF_b22_x, TF_b22_y, TF_b22_z)

// Mean-field profiles
Profile PROFILE_Umean_x, PROFILE_Umean_y, PROFILE_Umean_z

Profile PROFILE_ucrossb11mean_x, PROFILE_ucrossb11mean_y, PROFILE_ucrossb11mean_z
Profile PROFILE_ucrossb12mean_x, PROFILE_ucrossb12mean_y, PROFILE_ucrossb12mean_z
Profile PROFILE_ucrossb21mean_x, PROFILE_ucrossb21mean_y, PROFILE_ucrossb21mean_z
Profile PROFILE_ucrossb22mean_x, PROFILE_ucrossb22mean_y, PROFILE_ucrossb22mean_z

Profile PROFILE_B11mean_x, PROFILE_B11mean_y, PROFILE_B11mean_z
Profile PROFILE_B12mean_x, PROFILE_B12mean_y, PROFILE_B12mean_z
Profile PROFILE_B21mean_x, PROFILE_B21mean_y, PROFILE_B21mean_z
Profile PROFILE_B22mean_x, PROFILE_B22mean_y, PROFILE_B22mean_z
#endif

// Device constants
real AC_dsx, AC_dsy, AC_dsz
real AC_dt
int AC_step_number

// Run parameters
real AC_cdt
real AC_cdtv
real AC_cdts
real AC_nu_visc
real AC_cs_sound
real AC_eta
real AC_mu0
real AC_cp_sound
real AC_gamma
real AC_cv_sound
real AC_lnT0
real AC_lnrho0
real AC_zeta
real AC_trans
real AC_nu_shock
real AC_K_heatcond

//  Forcing parameters. User configured.
real AC_forcing_magnitude
real AC_relhel
real AC_kmin
real AC_kmax
real AC_switch_forcing

//  Forcing parameters. Set by the generator.
real AC_forcing_phase
real AC_k_forcex
real AC_k_forcey
real AC_k_forcez
real AC_kaver
real AC_ff_hel_rex
real AC_ff_hel_rey
real AC_ff_hel_rez
real AC_ff_hel_imx
real AC_ff_hel_imy
real AC_ff_hel_imz

// Backwards compatibility (boundconds.cuh depends on these, not used here)
real AC_cs2_sound
real AC_hcond0_kramers
real AC_hflux
real AC_n_kramers
real AC_sigma_SBt
real AC_chi
real AC_chi_t
real AC_chi_t_prof1
real AC_center_x
real AC_center_y
real AC_center_z
// real AC_sum_radius
real AC_window_radius

// Stencils
Stencil value {
    [0][0][0] = 1
}

Stencil derx {
    [0][0][-3] = 1,
    [0][0][-2] = 1,
    [0][0][-1] = 1,
    [0][0][1]  = 1,
    [0][0][2]  = 1,
    [0][0][3]  = 1
}

Stencil dery {
    [0][-3][0] = 1,
    [0][-2][0] = 1,
    [0][-1][0] = 1,
    [0][1][0]  = 1,
    [0][2][0]  = 1,
    [0][3][0]  = 1
}

Stencil derz {
    [-3][0][0] = 1,
    [-2][0][0] = 1,
    [-1][0][0] = 1,
    [1][0][0]  = 1,
    [2][0][0]  = 1,
    [3][0][0]  = 1
}

Stencil derxx {
    [0][0][-3] = 1,
    [0][0][-2] = 1,
    [0][0][-1] = 1,
    [0][0][0]  = 1,
    [0][0][1]  = 1,
    [0][0][2]  = 1,
    [0][0][3]  = 1
}

Stencil deryy {
    [0][-3][0] = 1,
    [0][-2][0] = 1,
    [0][-1][0] = 1,
    [0][0][0]  = 1,
    [0][1][0]  = 1,
    [0][2][0]  = 1,
    [0][3][0]  = 1
}

Stencil derzz {
    [-3][0][0] = 1,
    [-2][0][0] = 1,
    [-1][0][0] = 1,
    [0][0][0]  = 1,
    [1][0][0]  = 1,
    [2][0][0]  = 1,
    [3][0][0]  = 1
}

Stencil derxy {
    [0][-3][-3] = 1,
    [0][-2][-2] = 1,
    [0][-1][-1] = 1,
    [0][0][0]  = 1,
    [0][1][1]  = 1,
    [0][2][2]  = 1,
    [0][3][3]  = 1,
    [0][-3][3] = 1,
    [0][-2][2] = 1,
    [0][-1][1] = 1,
    [0][1][-1] = 1,
    [0][2][-2] = 1,
    [0][3][-3] = 1
}

Stencil derxz {
    [-3][0][-3] = 1,
    [-2][0][-2] = 1,
    [-1][0][-1] = 1,
    [0][0][0]  = 1,
    [1][0][1]  = 1,
    [2][0][2]  = 1,
    [3][0][3]  = 1,
    [-3][0][3] = 1,
    [-2][0][2] = 1,
    [-1][0][1] = 1,
    [1][0][-1] = 1,
    [2][0][-2] = 1,
    [3][0][-3] = 1
}

Stencil deryz {
    [-3][-3][0] = 1,
    [-2][-2][0] = 1,
    [-1][-1][0] = 1,
    [0][0][0]  = 1,
    [1][1][0]  = 1,
    [2][2][0]  = 1,
    [3][3][0]  = 1,
    [-3][3][0] = 1,
    [-2][2][0] = 1,
    [-1][1][0] = 1,
    [1][-1][0] = 1,
    [2][-2][0] = 1,
    [3][-3][0] = 1
}

Stencil der6x_upwd {
    [0][0][-3] =  1,
    [0][0][-2] =  1,
    [0][0][-1] =  1,
    [0][0][0]  =  1,
    [0][0][1]  =  1,
    [0][0][2]  =  1,
    [0][0][3]  =  1
}

Stencil der6y_upwd {
    [0][-3][0] =  1,
    [0][-2][0] =  1,
    [0][-1][0] =  1,
    [0][0][0]  =  1,
    [0][1][0]  =  1,
    [0][2][0]  =  1,
    [0][3][0]  =  1
}

Stencil der6z_upwd {
    [-3][0][0] =  1,
    [-2][0][0] =  1,
    [-1][0][0] =  1,
    [0][0][0]  =  1,
    [1][0][0]  =  1,
    [2][0][0]  =  1,
    [3][0][0]  =  1
}

// Operations
vecvalue(v) {
    return real3(value(v.x), value(v.y), value(v.z))
}

vecvalue_abs(v) {
    return real3(fabs(value(v.x)), fabs(value(v.y)), fabs(value(v.z)))
}

gradient(s) {
    return real3(derx(s), dery(s), derz(s))
}

gradient6_upwd(s) {
    return real3(der6x_upwd(s), der6y_upwd(s), der6z_upwd(s))
}

gradients_upwd(v) {
    return Matrix(gradient6_upwd(v.x), gradient6_upwd(v.y), gradient6_upwd(v.z))
}

gradients(v) {
    return Matrix(gradient(v.x), gradient(v.y), gradient(v.z))
}

divergence(v) {
    return derx(v.x) + dery(v.y) + derz(v.z)
}

curl(v) {
    return real3(dery(v.z) - derz(v.y), derz(v.x) - derx(v.z), derx(v.y) - dery(v.x))
}

laplace(s) {
    return derxx(s) + deryy(s) + derzz(s)
}

veclaplace(v) {
    return real3(laplace(v.x), laplace(v.y), laplace(v.z))
}


stress_tensor(v) {
    Matrix S

    S.data[0][0] = (2.0 / 3.0) * derx(v.x) - (1.0 / 3.0) * (dery(v.y) + derz(v.z))
    S.data[0][1] = (1.0 / 2.0) * (dery(v.x) + derx(v.y))
    S.data[0][2] = (1.0 / 2.0) * (derz(v.x) + derx(v.z))

    S.data[1][0] = S.data[0][1]
    S.data[1][1] = (2.0 / 3.0) * dery(v.y) - (1.0 / 3.0) * (derx(v.x) + derz(v.z))
    S.data[1][2] = (1.0 / 2.0) * (derz(v.y) + dery(v.z))

    S.data[2][0] = S.data[0][2]
    S.data[2][1] = S.data[1][2]
    S.data[2][2] = (2.0 / 3.0) * derz(v.z) - (1.0 / 3.0) * (derx(v.x) + dery(v.y))

    return S
}

gradient_of_divergence(v) {
    return real3(
        derxx(v.x) + derxy(v.y) + derxz(v.z),
        derxy(v.x) + deryy(v.y) + deryz(v.z),
        derxz(v.x) + deryz(v.y) + derzz(v.z)
    )
}

contract(mat) {
    return dot(mat.row(0), mat.row(0)) +
           dot(mat.row(1), mat.row(1)) +
           dot(mat.row(2), mat.row(2))
}

// Simulation functions
#if LFORCING
// The Pencil Code forcing_hel_noshear(), manual Eq. 222, inspired forcing function with adjustable
// helicity
helical_forcing(k_force, xx, ff_re, ff_im, phi)
{
    real3 yy
    yy.x = xx.x * (2.0 * R_PI / (AC_dsx * globalGridN.x))
    yy.y = xx.y * (2.0 * R_PI / (AC_dsy * globalGridN.x))
    yy.z = xx.z * (2.0 * R_PI / (AC_dsz * globalGridN.x))

    cos_phi     = cos(phi)
    sin_phi     = sin(phi)
    cos_k_dot_x = cos(dot(k_force, yy))
    sin_k_dot_x = sin(dot(k_force, yy))
    real_comp_phase = cos_k_dot_x * cos_phi - sin_k_dot_x * sin_phi
    imag_comp_phase = cos_k_dot_x * sin_phi + sin_k_dot_x * cos_phi

    force = real3(ff_re.x * real_comp_phase - ff_im.x * imag_comp_phase,
                  ff_re.y * real_comp_phase - ff_im.y * imag_comp_phase,
                  ff_re.z * real_comp_phase - ff_im.z * imag_comp_phase)

    return force
}

forcing()
{
    xx = real3((globalVertexIdx.x - AC_nx_min) * AC_dsx,
               (globalVertexIdx.y - AC_ny_min) * AC_dsy,
               (globalVertexIdx.z - AC_nz_min) * AC_dsz)
    cs  = AC_cs_sound

    // Placeholders until determined properly
    k_force   = real3(AC_k_forcex,   AC_k_forcey,   AC_k_forcez  )
    ff_re     = real3(AC_ff_hel_rex, AC_ff_hel_rey, AC_ff_hel_rez)
    ff_im     = real3(AC_ff_hel_imx, AC_ff_hel_imy, AC_ff_hel_imz)

    // Determine that forcing funtion type at this point.
    force = helical_forcing(k_force, xx, ff_re, ff_im, AC_forcing_phase)

    // Scaling N = magnitude*cs*sqrt(k*cs/dt)  * dt
    NN = cs * AC_forcing_magnitude * sqrt(AC_kaver * cs)
    // sqrt(dt) because 1/sqrt(dt)*dt = sqrt(dt)
    force.x = sqrt(AC_dt) * NN * force.x
    force.y = sqrt(AC_dt) * NN * force.y
    force.z = sqrt(AC_dt) * NN * force.z

    return force
}
#endif // LFORCING

continuity() {
    return -dot(vecvalue(UU), gradient(VTXBUF_LNRHO)) - divergence(UU)
#if LUPWD
           + dot(vecvalue_abs(UU), gradient6_upwd(VTXBUF_LNRHO))
#endif
}

momentum() {
    S = stress_tensor(UU)
    cs2_sound = AC_cs_sound * AC_cs_sound
#if LENTROPY 
    cs2 = cs2_sound * exp(AC_gamma * value(VTXBUF_ENTROPY) / AC_cp_sound + (AC_gamma - 1.) * (value(VTXBUF_LNRHO) - AC_lnrho0))
#else
    cs2 = cs2_sound
#endif

#if LMAGNETIC
    j = (1. / AC_mu0) * (gradient_of_divergence(AA) - veclaplace(AA))
    B = curl(AA)
    inv_rho = 1. / exp(value(VTXBUF_LNRHO))
#endif

    mom = - gradients(UU) * vecvalue(UU)
#if LUPWD
          + gradients_upwd(UU) * vecvalue_abs(UU)
#endif
#if LENTROPY 
          - cs2 * ((1. / AC_cp_sound) * gradient(VTXBUF_ENTROPY) + gradient(VTXBUF_LNRHO))
#else
          - cs2 * gradient(VTXBUF_LNRHO)
#endif
#if LMAGNETIC
          + inv_rho * cross(j, B)
#endif
          + AC_nu_visc * (veclaplace(UU) + (1. / 3.) * gradient_of_divergence(UU)
                       + 2. * S * gradient(VTXBUF_LNRHO))
          + AC_zeta * gradient_of_divergence(UU)
#if LSHOCK
          + AC_nu_shock * (value(VTXBUF_SHOCK) * (divergence(UU) * gradient(VTXBUF_LNRHO) +
                                           gradient_of_divergence(UU)) +
                           divergence(UU) * gradient(VTXBUF_SHOCK))
#endif

    return mom
}

#if LMAGNETIC
induction() {
    return cross(vecvalue(UU), curl(AA)) + AC_eta * veclaplace(AA)
}
#endif

#if LENTROPY 
lnT() {
    return AC_lnT0
         + AC_gamma * value(VTXBUF_ENTROPY) / AC_cp_sound
         + (AC_gamma - 1.) * (value(VTXBUF_LNRHO) - AC_lnrho0)
}

heat_conduction() {
    inv_AC_cp_sound = 1. / AC_cp_sound
    grad_ln_chi = -gradient(VTXBUF_LNRHO)

    first_term = AC_gamma * inv_AC_cp_sound * laplace(VTXBUF_ENTROPY) + (AC_gamma - 1.) * laplace(VTXBUF_LNRHO)
    second_term = AC_gamma * inv_AC_cp_sound * gradient(VTXBUF_ENTROPY) + (AC_gamma - 1.) * gradient(VTXBUF_LNRHO)
    third_term = AC_gamma * (inv_AC_cp_sound * gradient(VTXBUF_ENTROPY) + gradient(VTXBUF_LNRHO)) + grad_ln_chi

    //chi = AC_THERMAL_CONDUCTIVITY / (exp(value(VTXBUF_LNRHO)) * AC_cp_sound)
    chi = AC_K_heatcond / (exp(value(VTXBUF_LNRHO)) * AC_cp_sound)

    return AC_cp_sound * chi * (first_term + dot(second_term, third_term))
}

entropy() {
    S = stress_tensor(UU)
    inv_pT = 1. / (exp(value(VTXBUF_LNRHO)) * exp(lnT()))
#if LMAGNETIC
    j = (1. / AC_mu0) * (gradient_of_divergence(AA) - veclaplace(AA))
#else
    j = real3(0,0,0)
#endif
#if LSHOCK
    entshock = AC_nu_shock * value(VTXBUF_SHOCK) * (divergence(UU) * divergence(UU))  
#else
    entshock = 0.0
#endif
    RHS = (0) - (0) + AC_eta * AC_mu0 * dot(j, j) +
                       2. * exp(value(VTXBUF_LNRHO)) * AC_nu_visc * contract(S) +
                       entshock +
                       AC_zeta * exp(value(VTXBUF_LNRHO)) * divergence(UU) * divergence(UU)

    return -dot(vecvalue(UU), gradient(VTXBUF_ENTROPY)) + inv_pT * RHS + heat_conduction()
}
#endif

// Integration: single-pass
rk3(s0, s1, roc) {
    /*
    real alpha = 0., -5./9., -153. / 128.
    real beta = 1. / 3., 15./ 16., 8. / 15.

    // This conditional has abysmal performance on AMD for some reason, better performance on NVIDIA than the workaround below
    if AC_step_number > 0 {
        return s1 + beta[AC_step_number] * ((alpha[AC_step_number] / beta[AC_step_number - 1]) * (s1 - s0) + roc * AC_dt)
    } else {
        return s1 + beta[AC_step_number] * roc * AC_dt
    }
    */
    // Workaround
    real alpha = 0., -5./9., -153. / 128.
    real beta  = 1., 1. / 3., 15./ 16., 8. / 15.

    return s1 + beta[AC_step_number + 1] * ((alpha[AC_step_number] / beta[AC_step_number]) * (s1 - s0) + roc * AC_dt)
}

// Integration: two-pass
rk3_intermediate(w, roc) {
    real alpha = 0., -5./9., -153. / 128.
    return alpha[AC_step_number] * w + roc * AC_dt
    /*
    // TODO NOTE abysmal performance on AMD, needs a workaround like in rk3() 
    if AC_step_number > 0 {
        return alpha[AC_step_number] * w + roc * AC_dt
    } else {
        return roc * AC_dt
    }
    */
}

rk3_final(f, w) {
    real beta = 1. / 3., 15./ 16., 8. / 15.

    /*
    #ifndef NDEBUG
    if (AC_step_number >= len(beta)) {
        print("AC_step_number invalid: '%d'\n", AC_step_number)
    }
    #endif
    */

    return f + beta[AC_step_number] * w
}

#if LTFM
roc_TF_b21_x() {
    return AC_eta*(derxx(TF_b21_x) + deryy(TF_b21_x) + derzz(TF_b21_x)) + value(FIELD_u_x)*derz(PROFILE_B21mean_z) + value(FIELD_u_x)*dery(TF_b21_y) + value(FIELD_u_x)*derz(TF_b21_z) - value(FIELD_u_y)*dery(TF_b21_x) - value(FIELD_u_z)*derz(PROFILE_B21mean_x) - value(FIELD_u_z)*derz(TF_b21_x) - value(PROFILE_B21mean_x)*dery(FIELD_u_y) - value(PROFILE_B21mean_x)*derz(FIELD_u_z) + value(PROFILE_B21mean_y)*dery(FIELD_u_x) + value(PROFILE_B21mean_z)*derz(FIELD_u_x) + value(PROFILE_Umean_x)*dery(TF_b21_y) + value(PROFILE_Umean_x)*derz(TF_b21_z) - value(PROFILE_Umean_y)*dery(TF_b21_x) - value(PROFILE_Umean_z)*derz(TF_b21_x) - value(TF_b21_x)*dery(FIELD_u_y) - value(TF_b21_x)*derz(FIELD_u_z) - value(TF_b21_x)*derz(PROFILE_Umean_z) + value(TF_b21_y)*dery(FIELD_u_x) + value(TF_b21_z)*derz(FIELD_u_x) + value(TF_b21_z)*derz(PROFILE_Umean_x) + derz(PROFILE_ucrossb21mean_y)
}
roc_TF_b21_y() {
    return AC_eta*(derxx(TF_b21_y) + deryy(TF_b21_y) + derzz(TF_b21_y)) - value(FIELD_u_x)*derx(TF_b21_y) + value(FIELD_u_y)*derz(PROFILE_B21mean_z) + value(FIELD_u_y)*derx(TF_b21_x) + value(FIELD_u_y)*derz(TF_b21_z) - value(FIELD_u_z)*derz(PROFILE_B21mean_y) - value(FIELD_u_z)*derz(TF_b21_y) + value(PROFILE_B21mean_x)*derx(FIELD_u_y) - value(PROFILE_B21mean_y)*derx(FIELD_u_x) - value(PROFILE_B21mean_y)*derz(FIELD_u_z) + value(PROFILE_B21mean_z)*derz(FIELD_u_y) - value(PROFILE_Umean_x)*derx(TF_b21_y) + value(PROFILE_Umean_y)*derx(TF_b21_x) + value(PROFILE_Umean_y)*derz(TF_b21_z) - value(PROFILE_Umean_z)*derz(TF_b21_y) + value(TF_b21_x)*derx(FIELD_u_y) - value(TF_b21_y)*derx(FIELD_u_x) - value(TF_b21_y)*derz(FIELD_u_z) - value(TF_b21_y)*derz(PROFILE_Umean_z) + value(TF_b21_z)*derz(FIELD_u_y) + value(TF_b21_z)*derz(PROFILE_Umean_y) - derz(PROFILE_ucrossb21mean_x)
}
roc_TF_b21_z() {
    return AC_eta*(derxx(TF_b21_z) + deryy(TF_b21_z) + derzz(TF_b21_z)) - value(FIELD_u_x)*derx(TF_b21_z) - value(FIELD_u_y)*dery(TF_b21_z) + value(FIELD_u_z)*derx(TF_b21_x) + value(FIELD_u_z)*dery(TF_b21_y) + value(PROFILE_B21mean_x)*derx(FIELD_u_z) + value(PROFILE_B21mean_y)*dery(FIELD_u_z) - value(PROFILE_B21mean_z)*derx(FIELD_u_x) - value(PROFILE_B21mean_z)*dery(FIELD_u_y) - value(PROFILE_Umean_x)*derx(TF_b21_z) - value(PROFILE_Umean_y)*dery(TF_b21_z) + value(PROFILE_Umean_z)*derx(TF_b21_x) + value(PROFILE_Umean_z)*dery(TF_b21_y) + value(TF_b21_x)*derx(FIELD_u_z) + value(TF_b21_y)*dery(FIELD_u_z) - value(TF_b21_z)*derx(FIELD_u_x) - value(TF_b21_z)*dery(FIELD_u_y)
}
roc_TF_b11_x() {
    return AC_eta*(derxx(TF_b11_x) + deryy(TF_b11_x) + derzz(TF_b11_x)) + value(FIELD_u_x)*derz(PROFILE_B11mean_z) + value(FIELD_u_x)*dery(TF_b11_y) + value(FIELD_u_x)*derz(TF_b11_z) - value(FIELD_u_y)*dery(TF_b11_x) - value(FIELD_u_z)*derz(PROFILE_B11mean_x) - value(FIELD_u_z)*derz(TF_b11_x) - value(PROFILE_B11mean_x)*dery(FIELD_u_y) - value(PROFILE_B11mean_x)*derz(FIELD_u_z) + value(PROFILE_B11mean_y)*dery(FIELD_u_x) + value(PROFILE_B11mean_z)*derz(FIELD_u_x) + value(PROFILE_Umean_x)*dery(TF_b11_y) + value(PROFILE_Umean_x)*derz(TF_b11_z) - value(PROFILE_Umean_y)*dery(TF_b11_x) - value(PROFILE_Umean_z)*derz(TF_b11_x) - value(TF_b11_x)*dery(FIELD_u_y) - value(TF_b11_x)*derz(FIELD_u_z) - value(TF_b11_x)*derz(PROFILE_Umean_z) + value(TF_b11_y)*dery(FIELD_u_x) + value(TF_b11_z)*derz(FIELD_u_x) + value(TF_b11_z)*derz(PROFILE_Umean_x) + derz(PROFILE_ucrossb11mean_y)
}
roc_TF_b11_y() {
    return AC_eta*(derxx(TF_b11_y) + deryy(TF_b11_y) + derzz(TF_b11_y)) - value(FIELD_u_x)*derx(TF_b11_y) + value(FIELD_u_y)*derz(PROFILE_B11mean_z) + value(FIELD_u_y)*derx(TF_b11_x) + value(FIELD_u_y)*derz(TF_b11_z) - value(FIELD_u_z)*derz(PROFILE_B11mean_y) - value(FIELD_u_z)*derz(TF_b11_y) + value(PROFILE_B11mean_x)*derx(FIELD_u_y) - value(PROFILE_B11mean_y)*derx(FIELD_u_x) - value(PROFILE_B11mean_y)*derz(FIELD_u_z) + value(PROFILE_B11mean_z)*derz(FIELD_u_y) - value(PROFILE_Umean_x)*derx(TF_b11_y) + value(PROFILE_Umean_y)*derx(TF_b11_x) + value(PROFILE_Umean_y)*derz(TF_b11_z) - value(PROFILE_Umean_z)*derz(TF_b11_y) + value(TF_b11_x)*derx(FIELD_u_y) - value(TF_b11_y)*derx(FIELD_u_x) - value(TF_b11_y)*derz(FIELD_u_z) - value(TF_b11_y)*derz(PROFILE_Umean_z) + value(TF_b11_z)*derz(FIELD_u_y) + value(TF_b11_z)*derz(PROFILE_Umean_y) - derz(PROFILE_ucrossb11mean_x)
}
roc_TF_b11_z() {
    return AC_eta*(derxx(TF_b11_z) + deryy(TF_b11_z) + derzz(TF_b11_z)) - value(FIELD_u_x)*derx(TF_b11_z) - value(FIELD_u_y)*dery(TF_b11_z) + value(FIELD_u_z)*derx(TF_b11_x) + value(FIELD_u_z)*dery(TF_b11_y) + value(PROFILE_B11mean_x)*derx(FIELD_u_z) + value(PROFILE_B11mean_y)*dery(FIELD_u_z) - value(PROFILE_B11mean_z)*derx(FIELD_u_x) - value(PROFILE_B11mean_z)*dery(FIELD_u_y) - value(PROFILE_Umean_x)*derx(TF_b11_z) - value(PROFILE_Umean_y)*dery(TF_b11_z) + value(PROFILE_Umean_z)*derx(TF_b11_x) + value(PROFILE_Umean_z)*dery(TF_b11_y) + value(TF_b11_x)*derx(FIELD_u_z) + value(TF_b11_y)*dery(FIELD_u_z) - value(TF_b11_z)*derx(FIELD_u_x) - value(TF_b11_z)*dery(FIELD_u_y)
}
roc_TF_b12_x() {
    return AC_eta*(derxx(TF_b12_x) + deryy(TF_b12_x) + derzz(TF_b12_x)) + value(FIELD_u_x)*derz(PROFILE_B12mean_z) + value(FIELD_u_x)*dery(TF_b12_y) + value(FIELD_u_x)*derz(TF_b12_z) - value(FIELD_u_y)*dery(TF_b12_x) - value(FIELD_u_z)*derz(PROFILE_B12mean_x) - value(FIELD_u_z)*derz(TF_b12_x) - value(PROFILE_B12mean_x)*dery(FIELD_u_y) - value(PROFILE_B12mean_x)*derz(FIELD_u_z) + value(PROFILE_B12mean_y)*dery(FIELD_u_x) + value(PROFILE_B12mean_z)*derz(FIELD_u_x) + value(PROFILE_Umean_x)*dery(TF_b12_y) + value(PROFILE_Umean_x)*derz(TF_b12_z) - value(PROFILE_Umean_y)*dery(TF_b12_x) - value(PROFILE_Umean_z)*derz(TF_b12_x) - value(TF_b12_x)*dery(FIELD_u_y) - value(TF_b12_x)*derz(FIELD_u_z) - value(TF_b12_x)*derz(PROFILE_Umean_z) + value(TF_b12_y)*dery(FIELD_u_x) + value(TF_b12_z)*derz(FIELD_u_x) + value(TF_b12_z)*derz(PROFILE_Umean_x) + derz(PROFILE_ucrossb12mean_y)
}
roc_TF_b12_y() {
    return AC_eta*(derxx(TF_b12_y) + deryy(TF_b12_y) + derzz(TF_b12_y)) - value(FIELD_u_x)*derx(TF_b12_y) + value(FIELD_u_y)*derz(PROFILE_B12mean_z) + value(FIELD_u_y)*derx(TF_b12_x) + value(FIELD_u_y)*derz(TF_b12_z) - value(FIELD_u_z)*derz(PROFILE_B12mean_y) - value(FIELD_u_z)*derz(TF_b12_y) + value(PROFILE_B12mean_x)*derx(FIELD_u_y) - value(PROFILE_B12mean_y)*derx(FIELD_u_x) - value(PROFILE_B12mean_y)*derz(FIELD_u_z) + value(PROFILE_B12mean_z)*derz(FIELD_u_y) - value(PROFILE_Umean_x)*derx(TF_b12_y) + value(PROFILE_Umean_y)*derx(TF_b12_x) + value(PROFILE_Umean_y)*derz(TF_b12_z) - value(PROFILE_Umean_z)*derz(TF_b12_y) + value(TF_b12_x)*derx(FIELD_u_y) - value(TF_b12_y)*derx(FIELD_u_x) - value(TF_b12_y)*derz(FIELD_u_z) - value(TF_b12_y)*derz(PROFILE_Umean_z) + value(TF_b12_z)*derz(FIELD_u_y) + value(TF_b12_z)*derz(PROFILE_Umean_y) - derz(PROFILE_ucrossb12mean_x)
}
roc_TF_b12_z() {
    return AC_eta*(derxx(TF_b12_z) + deryy(TF_b12_z) + derzz(TF_b12_z)) - value(FIELD_u_x)*derx(TF_b12_z) - value(FIELD_u_y)*dery(TF_b12_z) + value(FIELD_u_z)*derx(TF_b12_x) + value(FIELD_u_z)*dery(TF_b12_y) + value(PROFILE_B12mean_x)*derx(FIELD_u_z) + value(PROFILE_B12mean_y)*dery(FIELD_u_z) - value(PROFILE_B12mean_z)*derx(FIELD_u_x) - value(PROFILE_B12mean_z)*dery(FIELD_u_y) - value(PROFILE_Umean_x)*derx(TF_b12_z) - value(PROFILE_Umean_y)*dery(TF_b12_z) + value(PROFILE_Umean_z)*derx(TF_b12_x) + value(PROFILE_Umean_z)*dery(TF_b12_y) + value(TF_b12_x)*derx(FIELD_u_z) + value(TF_b12_y)*dery(FIELD_u_z) - value(TF_b12_z)*derx(FIELD_u_x) - value(TF_b12_z)*dery(FIELD_u_y)
}
roc_TF_b22_x() {
    return AC_eta*(derxx(TF_b22_x) + deryy(TF_b22_x) + derzz(TF_b22_x)) + value(FIELD_u_x)*derz(PROFILE_B22mean_z) + value(FIELD_u_x)*dery(TF_b22_y) + value(FIELD_u_x)*derz(TF_b22_z) - value(FIELD_u_y)*dery(TF_b22_x) - value(FIELD_u_z)*derz(PROFILE_B22mean_x) - value(FIELD_u_z)*derz(TF_b22_x) - value(PROFILE_B22mean_x)*dery(FIELD_u_y) - value(PROFILE_B22mean_x)*derz(FIELD_u_z) + value(PROFILE_B22mean_y)*dery(FIELD_u_x) + value(PROFILE_B22mean_z)*derz(FIELD_u_x) + value(PROFILE_Umean_x)*dery(TF_b22_y) + value(PROFILE_Umean_x)*derz(TF_b22_z) - value(PROFILE_Umean_y)*dery(TF_b22_x) - value(PROFILE_Umean_z)*derz(TF_b22_x) - value(TF_b22_x)*dery(FIELD_u_y) - value(TF_b22_x)*derz(FIELD_u_z) - value(TF_b22_x)*derz(PROFILE_Umean_z) + value(TF_b22_y)*dery(FIELD_u_x) + value(TF_b22_z)*derz(FIELD_u_x) + value(TF_b22_z)*derz(PROFILE_Umean_x) + derz(PROFILE_ucrossb22mean_y)
}
roc_TF_b22_y() {
    return AC_eta*(derxx(TF_b22_y) + deryy(TF_b22_y) + derzz(TF_b22_y)) - value(FIELD_u_x)*derx(TF_b22_y) + value(FIELD_u_y)*derz(PROFILE_B22mean_z) + value(FIELD_u_y)*derx(TF_b22_x) + value(FIELD_u_y)*derz(TF_b22_z) - value(FIELD_u_z)*derz(PROFILE_B22mean_y) - value(FIELD_u_z)*derz(TF_b22_y) + value(PROFILE_B22mean_x)*derx(FIELD_u_y) - value(PROFILE_B22mean_y)*derx(FIELD_u_x) - value(PROFILE_B22mean_y)*derz(FIELD_u_z) + value(PROFILE_B22mean_z)*derz(FIELD_u_y) - value(PROFILE_Umean_x)*derx(TF_b22_y) + value(PROFILE_Umean_y)*derx(TF_b22_x) + value(PROFILE_Umean_y)*derz(TF_b22_z) - value(PROFILE_Umean_z)*derz(TF_b22_y) + value(TF_b22_x)*derx(FIELD_u_y) - value(TF_b22_y)*derx(FIELD_u_x) - value(TF_b22_y)*derz(FIELD_u_z) - value(TF_b22_y)*derz(PROFILE_Umean_z) + value(TF_b22_z)*derz(FIELD_u_y) + value(TF_b22_z)*derz(PROFILE_Umean_y) - derz(PROFILE_ucrossb22mean_x)
}
roc_TF_b22_z() {
    return AC_eta*(derxx(TF_b22_z) + deryy(TF_b22_z) + derzz(TF_b22_z)) - value(FIELD_u_x)*derx(TF_b22_z) - value(FIELD_u_y)*dery(TF_b22_z) + value(FIELD_u_z)*derx(TF_b22_x) + value(FIELD_u_z)*dery(TF_b22_y) + value(PROFILE_B22mean_x)*derx(FIELD_u_z) + value(PROFILE_B22mean_y)*dery(FIELD_u_z) - value(PROFILE_B22mean_z)*derx(FIELD_u_x) - value(PROFILE_B22mean_z)*dery(FIELD_u_y) - value(PROFILE_Umean_x)*derx(TF_b22_z) - value(PROFILE_Umean_y)*dery(TF_b22_z) + value(PROFILE_Umean_z)*derx(TF_b22_x) + value(PROFILE_Umean_z)*dery(TF_b22_y) + value(TF_b22_x)*derx(FIELD_u_z) + value(TF_b22_y)*dery(FIELD_u_z) - value(TF_b22_z)*derx(FIELD_u_x) - value(TF_b22_z)*dery(FIELD_u_y)
}
tfm_singlepass() {
    write(TF_b21_x, rk3(previous(TF_b21_x), value(TF_b21_x), roc_TF_b21_x()))
    write(TF_b21_y, rk3(previous(TF_b21_y), value(TF_b21_y), roc_TF_b21_y()))
    write(TF_b21_z, rk3(previous(TF_b21_z), value(TF_b21_z), roc_TF_b21_z()))
    write(TF_b11_x, rk3(previous(TF_b11_x), value(TF_b11_x), roc_TF_b11_x()))
    write(TF_b11_y, rk3(previous(TF_b11_y), value(TF_b11_y), roc_TF_b11_y()))
    write(TF_b11_z, rk3(previous(TF_b11_z), value(TF_b11_z), roc_TF_b11_z()))
    write(TF_b12_x, rk3(previous(TF_b12_x), value(TF_b12_x), roc_TF_b12_x()))
    write(TF_b12_y, rk3(previous(TF_b12_y), value(TF_b12_y), roc_TF_b12_y()))
    write(TF_b12_z, rk3(previous(TF_b12_z), value(TF_b12_z), roc_TF_b12_z()))
    write(TF_b22_x, rk3(previous(TF_b22_x), value(TF_b22_x), roc_TF_b22_x()))
    write(TF_b22_y, rk3(previous(TF_b22_y), value(TF_b22_y), roc_TF_b22_y()))
    write(TF_b22_z, rk3(previous(TF_b22_z), value(TF_b22_z), roc_TF_b22_z()))
}
Kernel singlepass_solve_tfm_b21(){
    write(TF_b21_x, rk3(previous(TF_b21_x), value(TF_b21_x), roc_TF_b21_x()))
    write(TF_b21_y, rk3(previous(TF_b21_y), value(TF_b21_y), roc_TF_b21_y()))
    write(TF_b21_z, rk3(previous(TF_b21_z), value(TF_b21_z), roc_TF_b21_z()))
}
Kernel singlepass_solve_tfm_b11(){
    write(TF_b11_x, rk3(previous(TF_b11_x), value(TF_b11_x), roc_TF_b11_x()))
    write(TF_b11_y, rk3(previous(TF_b11_y), value(TF_b11_y), roc_TF_b11_y()))
    write(TF_b11_z, rk3(previous(TF_b11_z), value(TF_b11_z), roc_TF_b11_z()))
}
Kernel singlepass_solve_tfm_b12(){
    write(TF_b12_x, rk3(previous(TF_b12_x), value(TF_b12_x), roc_TF_b12_x()))
    write(TF_b12_y, rk3(previous(TF_b12_y), value(TF_b12_y), roc_TF_b12_y()))
    write(TF_b12_z, rk3(previous(TF_b12_z), value(TF_b12_z), roc_TF_b12_z()))
}
Kernel singlepass_solve_tfm_b22(){
    write(TF_b22_x, rk3(previous(TF_b22_x), value(TF_b22_x), roc_TF_b22_x()))
    write(TF_b22_y, rk3(previous(TF_b22_y), value(TF_b22_y), roc_TF_b22_y()))
    write(TF_b22_z, rk3(previous(TF_b22_z), value(TF_b22_z), roc_TF_b22_z()))
}
tfm_twopass_intermediate() {
    write(TF_b21_x, rk3_intermediate(previous(TF_b21_x), roc_TF_b21_x()))
    write(TF_b21_y, rk3_intermediate(previous(TF_b21_y), roc_TF_b21_y()))
    write(TF_b21_z, rk3_intermediate(previous(TF_b21_z), roc_TF_b21_z()))
    write(TF_b11_x, rk3_intermediate(previous(TF_b11_x), roc_TF_b11_x()))
    write(TF_b11_y, rk3_intermediate(previous(TF_b11_y), roc_TF_b11_y()))
    write(TF_b11_z, rk3_intermediate(previous(TF_b11_z), roc_TF_b11_z()))
    write(TF_b12_x, rk3_intermediate(previous(TF_b12_x), roc_TF_b12_x()))
    write(TF_b12_y, rk3_intermediate(previous(TF_b12_y), roc_TF_b12_y()))
    write(TF_b12_z, rk3_intermediate(previous(TF_b12_z), roc_TF_b12_z()))
    write(TF_b22_x, rk3_intermediate(previous(TF_b22_x), roc_TF_b22_x()))
    write(TF_b22_y, rk3_intermediate(previous(TF_b22_y), roc_TF_b22_y()))
    write(TF_b22_z, rk3_intermediate(previous(TF_b22_z), roc_TF_b22_z()))
}
tfm_twopass_final() {
    write(TF_b21_x, rk3_final(previous(TF_b21_x), value(TF_b21_x)))
    write(TF_b21_y, rk3_final(previous(TF_b21_y), value(TF_b21_y)))
    write(TF_b21_z, rk3_final(previous(TF_b21_z), value(TF_b21_z)))
    write(TF_b11_x, rk3_final(previous(TF_b11_x), value(TF_b11_x)))
    write(TF_b11_y, rk3_final(previous(TF_b11_y), value(TF_b11_y)))
    write(TF_b11_z, rk3_final(previous(TF_b11_z), value(TF_b11_z)))
    write(TF_b12_x, rk3_final(previous(TF_b12_x), value(TF_b12_x)))
    write(TF_b12_y, rk3_final(previous(TF_b12_y), value(TF_b12_y)))
    write(TF_b12_z, rk3_final(previous(TF_b12_z), value(TF_b12_z)))
    write(TF_b22_x, rk3_final(previous(TF_b22_x), value(TF_b22_x)))
    write(TF_b22_y, rk3_final(previous(TF_b22_y), value(TF_b22_y)))
    write(TF_b22_z, rk3_final(previous(TF_b22_z), value(TF_b22_z)))
}
#endif

Kernel singlepass_solve() {
    write(VTXBUF_LNRHO, rk3(previous(VTXBUF_LNRHO), value(VTXBUF_LNRHO), continuity()))

#if LENTROPY 
    write(VTXBUF_ENTROPY, rk3(previous(VTXBUF_ENTROPY), value(VTXBUF_ENTROPY), entropy()))
#endif 
    mom = momentum()

#if LFORCING
    //Add the forcing component to the velocity field at the last integration step.
    //Important to init to zero here: ohterwise will produce numerical garbage! 
    forcing_step = real3(0.0, 0.0, 0.0)
    if AC_step_number == 2 {
        if AC_current_time > AC_switch_forcing {
            forcing_step = forcing()
        }
    }
    write(VTXBUF_UUX, rk3(previous(VTXBUF_UUX), value(VTXBUF_UUX), mom.x) + forcing_step.x)
    write(VTXBUF_UUY, rk3(previous(VTXBUF_UUY), value(VTXBUF_UUY), mom.y) + forcing_step.y)
    write(VTXBUF_UUZ, rk3(previous(VTXBUF_UUZ), value(VTXBUF_UUZ), mom.z) + forcing_step.z)
#else 
    write(VTXBUF_UUX, rk3(previous(VTXBUF_UUX), value(VTXBUF_UUX), mom.x))
    write(VTXBUF_UUY, rk3(previous(VTXBUF_UUY), value(VTXBUF_UUY), mom.y))
    write(VTXBUF_UUZ, rk3(previous(VTXBUF_UUZ), value(VTXBUF_UUZ), mom.z))
#endif

#if LMAGNETIC
    ind = induction()
    write(VTXBUF_AX, rk3(previous(VTXBUF_AX), value(VTXBUF_AX), ind.x))
    write(VTXBUF_AY, rk3(previous(VTXBUF_AY), value(VTXBUF_AY), ind.y))
    write(VTXBUF_AZ, rk3(previous(VTXBUF_AZ), value(VTXBUF_AZ), ind.z))
#endif
}

Kernel twopass_solve_intermediate() {
    write(VTXBUF_LNRHO, rk3_intermediate(previous(VTXBUF_LNRHO), continuity()))

    #if LENTROPY 
    write(VTXBUF_ENTROPY, rk3_intermediate(previous(VTXBUF_ENTROPY), entropy()))
    #endif

    mom = momentum()
    write(VTXBUF_UUX, rk3_intermediate(previous(VTXBUF_UUX), mom.x))
    write(VTXBUF_UUY, rk3_intermediate(previous(VTXBUF_UUY), mom.y))
    write(VTXBUF_UUZ, rk3_intermediate(previous(VTXBUF_UUZ), mom.z))

    #if LMAGNETIC
    ind = induction()
    write(VTXBUF_AX, rk3_intermediate(previous(VTXBUF_AX), ind.x))
    write(VTXBUF_AY, rk3_intermediate(previous(VTXBUF_AY), ind.y))
    write(VTXBUF_AZ, rk3_intermediate(previous(VTXBUF_AZ), ind.z))
    #endif

    #if LBFIELD
    if AC_step_number == 2 {
        bfield = curl(AA) 
        write(BFIELDX, bfield.x)
        write(BFIELDY, bfield.y)
        write(BFIELDZ, bfield.z)
    }
    #endif

    // %JP: TODO NOTE IMPORTANT (MV please check)
    // LSHOCK not yet adapted to two-pass integration.
    // Unclear how should be written to memory to ensure proper swapping!
    // 1) In the single-pass approach need to write the shock field to `out`
    // because buffers are swapped afterwards
    // 2) In the two-pass approach this may not be necessary: if the shock
    // field is in `in` buffer and we swap twice, the correct shock values are
    // still in the `in` buffer
    //
    // Is this correct?
    //

    #if LTFM
        tfm_twopass_intermediate()
    #endif
}

Kernel twopass_solve_final() {
    write(VTXBUF_LNRHO, rk3_final(previous(VTXBUF_LNRHO), value(VTXBUF_LNRHO)))

    #if LENTROPY 
    write(VTXBUF_ENTROPY, rk3_final(previous(VTXBUF_ENTROPY), value(VTXBUF_ENTROPY)))
    #endif

    forcing_step = real3(0.0, 0.0, 0.0)
    #if LFORCING
    if AC_step_number == 2 {
        if AC_current_time > AC_switch_forcing {
            forcing_step = forcing()
        }
    }
    #endif
    write(VTXBUF_UUX, rk3_final(previous(VTXBUF_UUX), value(VTXBUF_UUX)) + forcing_step.x)
    write(VTXBUF_UUY, rk3_final(previous(VTXBUF_UUY), value(VTXBUF_UUY)) + forcing_step.y)
    write(VTXBUF_UUZ, rk3_final(previous(VTXBUF_UUZ), value(VTXBUF_UUZ)) + forcing_step.z)

    #if LMAGNETIC
    write(VTXBUF_AX, rk3_final(previous(VTXBUF_AX), value(VTXBUF_AX)))
    write(VTXBUF_AY, rk3_final(previous(VTXBUF_AY), value(VTXBUF_AY)))
    write(VTXBUF_AZ, rk3_final(previous(VTXBUF_AZ), value(VTXBUF_AZ)))
    #endif

    #if LBFIELD
    if AC_step_number == 2 {
        write(BFIELDX, value(BFIELDX))
        write(BFIELDY, value(BFIELDY))
        write(BFIELDZ, value(BFIELDZ))
    }
    #endif

    #if LTFM
        tfm_twopass_final()
    #endif
}

#if LTFM
Kernel init_profiles() {
    for i in PROFILE_Umean_x:PROFILE_Umean_x+NUM_PROFILES {
        write(i, 0)
    }
}

Kernel diff_profiles() {
    for i in PROFILE_Umean_x:PROFILE_Umean_x+NUM_PROFILES {
        write(i, derz(i))
    }
}

Kernel diff2_profiles() {
    for i in PROFILE_Umean_x:PROFILE_Umean_x+NUM_PROFILES {
        write(i, derzz(i))
    }
}
#endif

Kernel randomize() {
    
    // N.B. scale: result in (-AC_rng_scale, AC_rng_scale] range
    AC_rng_scale = 1e-5

    for field in 0:NUM_FIELDS+NUM_PROFILES {
        r = 2.0 * rand_uniform() - 1.0
        write(field, AC_rng_scale * r)
    }
}