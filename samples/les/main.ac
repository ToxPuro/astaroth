#include "stencil.ach"

Field UUX, UUY, UUZ
Field RHO

Field T00, T01, T02, T11, T12, T22 // Note: the stress tensor is symmetric

#define UU Field3(UUX, UUY, UUZ)

#define TEMPERATURE_T (298) // 25 deg C
#define UNIVERSAL_GAS_CONSTANT_R (8.31446261815324)
#define DYNAMIC_VISCOSITY_MU (0.89e-3) // mPA*s, Water at 25 deg C
#define SMAGORINSKY_COEFFICIENT_C (1)
#define CHARACTERISTIC_SCALE (DSX)

kinematic_viscosity()
{
   return DYNAMIC_VISCOSITY_MU / value(RHO)
}

temperature()
{
   return TEMPERATURE_T
}

pressure(rho)
{
   return rho * UNIVERSAL_GAS_CONSTANT_R * temperature()
}

// TODO check that calculated correctly for LES
stress_tensor(v)
{
    Matrix S

    S.data[0][0] = (2.0 / 3.0) * ddx(v.x) - (1.0 / 3.0) * (ddy(v.y) + ddz(v.z))
    S.data[0][1] = (1.0 / 2.0) * (ddy(v.x) + ddx(v.y))
    S.data[0][2] = (1.0 / 2.0) * (ddz(v.x) + ddx(v.z))

    S.data[1][0] = S.data[0][1]
    S.data[1][1] = (2.0 / 3.0) * ddy(v.y) - (1.0 / 3.0) * (ddx(v.x) + ddz(v.z))
    S.data[1][2] = (1.0 / 2.0) * (ddz(v.y) + ddy(v.z))

    S.data[2][0] = S.data[0][2]
    S.data[2][1] = S.data[1][2]
    S.data[2][2] = (2.0 / 3.0) * ddz(v.z) - (1.0 / 3.0) * (ddx(v.x) + ddy(v.y))

    return S
}

// TODO check that calculated correctly (the result is a scalar instead of a tensor)
galilean_invariant_estimation(mat)
{
   prod = dot(mat.row(0), mat.row(0)) +
          dot(mat.row(1), mat.row(1)) +
          dot(mat.row(2), mat.row(2))

   return sqrt(2 * prod)
}

smagorinsky_eddy_viscosity(stress)
{
   return pow(SMAGORINSKY_COEFFICIENT_C * CHARACTERISTIC_SCALE, 2) * galilean_invariant_estimation(stress)
}

stress_tau()
{
   stress = stress_tensor(UU)
   return -2 * smagorinsky_eddy_viscosity(stress) * stress
}

Kernel compute_stress_tensor_tau()
{
   stress = stress_tau()
   write(T00, stress.data[0][0])
   write(T01, stress.data[0][1])
   write(T02, stress.data[0][2])
   write(T11, stress.data[1][1])
   write(T12, stress.data[1][2])
   write(T22, stress.data[2][2])
}

construct_stress_term()
{
   x = ddx(T00) + ddy(T01) + ddz(T02)
   y = ddx(T01) + ddy(T11) + ddz(T12)
   z = ddx(T02) + ddy(T12) + ddz(T22)

   return real3(x, y, z)
}

momentum()
{
   // TODO figure out
   // Note: grad_p and visc_term cause the simulation to explode

   u_dot_grad_u = gradients(UU) * vecvalue(UU)
   grad_p = real3(0,0,0) // pressure(gradient(RHO)) // TODO DEBUG
   pressure_term = (1.0 / value(RHO)) * grad_p
   visc_term = real3(0,0,0) //kinematic_viscosity() * veclaplace(UU)// TODO DEBUG
   stress_term = construct_stress_term()
   return - u_dot_grad_u - pressure_term + visc_term - stress_term
}

divergence_multivariate(scal, vec)
{
   x = scal * ddx(vec.x) + vec.x * ddx(scal)
   y = scal * ddx(vec.y) + vec.y * ddy(scal)
   z = scal * ddx(vec.z) + vec.z * ddz(scal)
   return x + y + z
}

continuity()
{
   return - divergence_multivariate(RHO, UU)
   //return -dot(vecvalue(UU), gradient(RHO)) - divergence(UU)
}

Kernel singlepass_solve()
{
   mom = momentum()
   write(UUX, rk3(previous(UUX), value(UUX), mom.x))
   write(UUY, rk3(previous(UUY), value(UUY), mom.y))
   write(UUZ, rk3(previous(UUZ), value(UUZ), mom.z))

   write(RHO, rk3(previous(RHO), value(RHO), continuity()))
}